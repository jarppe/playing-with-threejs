/**********************************************************************
 * Extern for THREE
 * Generated by http://jmmk.github.io/javascript-externs-generator
 **********************************************************************/
var THREE = {
  "AddEquation": {},
  "AddOperation": {},
  "AdditiveBlending": {},
  "AlphaFormat": {},
  "AlwaysDepth": {},
  "AmbientLight": function () {},
  "AnimationClip": {
    "CreateClipsFromMorphTargetSequences": function () {},
    "CreateFromMorphTargetSequence": function () {},
    "findByName": function () {},
    "parse": function () {},
    "parseAnimation": function () {},
    "toJSON": function () {}
  },
  "AnimationMixer": function () {},
  "AnimationObjectGroup": function () {},
  "AnimationUtils": {
    "arraySlice": function () {},
    "convertArray": function () {},
    "flattenJSON": function () {},
    "getKeyframeOrder": function () {},
    "isTypedArray": function () {},
    "sortedArray": function () {}
  },
  "ArcCurve": function () {},
  "ArrayCamera": function () {},
  "ArrowHelper": function () {},
  "Audio": function () {},
  "AudioAnalyser": function () {},
  "AudioContext": {
    "getContext": function () {},
    "setContext": function () {}
  },
  "AudioListener": function () {},
  "AudioLoader": function () {},
  "AxesHelper": function () {},
  "AxisHelper": function () {},
  "BackSide": {},
  "BasicDepthPacking": {},
  "BasicShadowMap": {},
  "BinaryTextureLoader": function () {},
  "Bone": function () {},
  "BooleanKeyframeTrack": function () {},
  "BoundingBoxHelper": function () {},
  "Box2": function () {},
  "Box3": function () {},
  "Box3Helper": function () {},
  "BoxBufferGeometry": function () {},
  "BoxGeometry": function () {},
  "BoxHelper": function () {},
  "BufferAttribute": function () {},
  "BufferGeometry": function () {},
  "BufferGeometryLoader": function () {},
  "ByteType": {},
  "Cache": {
    "add": function () {},
    "clear": function () {},
    "enabled": {},
    "files": {},
    "get": function () {},
    "remove": function () {}
  },
  "Camera": function () {},
  "CameraHelper": function () {},
  "CanvasRenderer": function () {},
  "CanvasTexture": function () {},
  "CatmullRomCurve3": function () {},
  "CineonToneMapping": {},
  "CircleBufferGeometry": function () {},
  "CircleGeometry": function () {},
  "ClampToEdgeWrapping": {},
  "Clock": function () {},
  "ClosedSplineCurve3": function () {},
  "Color": function () {},
  "ColorKeyframeTrack": function () {},
  "CompressedTexture": function () {},
  "CompressedTextureLoader": function () {},
  "ConeBufferGeometry": function () {},
  "ConeGeometry": function () {},
  "CubeCamera": function () {},
  "CubeGeometry": function () {},
  "CubeReflectionMapping": {},
  "CubeRefractionMapping": {},
  "CubeTexture": function () {},
  "CubeTextureLoader": function () {},
  "CubeUVReflectionMapping": {},
  "CubeUVRefractionMapping": {},
  "CubicBezierCurve": function () {},
  "CubicBezierCurve3": function () {},
  "CubicInterpolant": function () {},
  "CullFaceBack": {},
  "CullFaceFront": {},
  "CullFaceFrontBack": {},
  "CullFaceNone": {},
  "Curve": {
    "create": function () {}
  },
  "CurvePath": function () {},
  "CustomBlending": {},
  "CylinderBufferGeometry": function () {},
  "CylinderGeometry": function () {},
  "Cylindrical": function () {},
  "DataTexture": function () {},
  "DataTextureLoader": function () {},
  "DefaultLoadingManager": {
    "itemEnd": function () {},
    "itemError": function () {},
    "itemStart": function () {},
    "onError": {},
    "onLoad": {},
    "onProgress": {},
    "onStart": {},
    "resolveURL": function () {},
    "setURLModifier": function () {}
  },
  "DepthFormat": {},
  "DepthStencilFormat": {},
  "DepthTexture": function () {},
  "DirectionalLight": function () {},
  "DirectionalLightHelper": function () {},
  "DirectionalLightShadow": function () {},
  "DiscreteInterpolant": function () {},
  "DodecahedronBufferGeometry": function () {},
  "DodecahedronGeometry": function () {},
  "DoubleSide": {},
  "DstAlphaFactor": {},
  "DstColorFactor": {},
  "DynamicBufferAttribute": function () {},
  "EdgesGeometry": function () {},
  "EdgesHelper": function () {},
  "EllipseCurve": function () {},
  "EqualDepth": {},
  "EquirectangularReflectionMapping": {},
  "EquirectangularRefractionMapping": {},
  "Euler": {
    "DefaultOrder": {},
    "RotationOrders": {}
  },
  "EventDispatcher": function () {},
  "ExtrudeBufferGeometry": function () {},
  "ExtrudeGeometry": {
    "WorldUVGenerator": {
      "generateSideWallUV": function () {},
      "generateTopUV": function () {}
    }
  },
  "Face3": function () {},
  "Face4": function () {},
  "FaceColors": {},
  "FaceNormalsHelper": function () {},
  "FileLoader": function () {},
  "FlatShading": {},
  "Float32Attribute": function () {},
  "Float32BufferAttribute": function () {},
  "Float64Attribute": function () {},
  "Float64BufferAttribute": function () {},
  "FloatType": {},
  "Fog": function () {},
  "FogExp2": function () {},
  "Font": function () {},
  "FontLoader": function () {},
  "FrontFaceDirectionCCW": {},
  "FrontFaceDirectionCW": {},
  "FrontSide": {},
  "Frustum": function () {},
  "GammaEncoding": {},
  "Geometry": function () {},
  "GeometryUtils": {
    "center": function () {},
    "merge": function () {}
  },
  "GreaterDepth": {},
  "GreaterEqualDepth": {},
  "GridHelper": function () {},
  "Group": function () {},
  "HalfFloatType": {},
  "HemisphereLight": function () {},
  "HemisphereLightHelper": function () {},
  "IcosahedronBufferGeometry": function () {},
  "IcosahedronGeometry": function () {},
  "ImageBitmapLoader": function () {},
  "ImageLoader": function () {},
  "ImageUtils": {
    "crossOrigin": {},
    "loadCompressedTexture": function () {},
    "loadCompressedTextureCube": function () {},
    "loadTexture": function () {},
    "loadTextureCube": function () {}
  },
  "ImmediateRenderObject": function () {},
  "InstancedBufferAttribute": function () {},
  "InstancedBufferGeometry": function () {},
  "InstancedInterleavedBuffer": function () {},
  "Int16Attribute": function () {},
  "Int16BufferAttribute": function () {},
  "Int32Attribute": function () {},
  "Int32BufferAttribute": function () {},
  "Int8Attribute": function () {},
  "Int8BufferAttribute": function () {},
  "IntType": {},
  "InterleavedBuffer": function () {},
  "InterleavedBufferAttribute": function () {},
  "Interpolant": function () {},
  "InterpolateDiscrete": {},
  "InterpolateLinear": {},
  "InterpolateSmooth": {},
  "JSONLoader": function () {},
  "KeyframeTrack": {
    "_getTrackTypeForValueTypeName": function () {},
    "parse": function () {},
    "toJSON": function () {}
  },
  "LOD": function () {},
  "LatheBufferGeometry": function () {},
  "LatheGeometry": function () {},
  "Layers": function () {},
  "LensFlare": function () {},
  "LessDepth": {},
  "LessEqualDepth": {},
  "Light": function () {},
  "LightShadow": function () {},
  "Line": function () {},
  "Line3": function () {},
  "LineBasicMaterial": function () {},
  "LineCurve": function () {},
  "LineCurve3": function () {},
  "LineDashedMaterial": function () {},
  "LineLoop": function () {},
  "LinePieces": {},
  "LineSegments": function () {},
  "LineStrip": {},
  "LinearEncoding": {},
  "LinearFilter": {},
  "LinearInterpolant": function () {},
  "LinearMipMapLinearFilter": {},
  "LinearMipMapNearestFilter": {},
  "LinearToneMapping": {},
  "Loader": {
    "Handlers": {
      "add": function () {},
      "get": function () {},
      "handlers": {}
    }
  },
  "LoaderUtils": {
    "decodeText": function () {},
    "extractUrlBase": function () {}
  },
  "LoadingManager": function () {},
  "LogLuvEncoding": {},
  "LoopOnce": {},
  "LoopPingPong": {},
  "LoopRepeat": {},
  "LuminanceAlphaFormat": {},
  "LuminanceFormat": {},
  "MOUSE": {
    "LEFT": {},
    "MIDDLE": {},
    "RIGHT": {}
  },
  "Material": function () {},
  "MaterialLoader": function () {},
  "Math": {
    "DEG2RAD": {},
    "RAD2DEG": {},
    "ceilPowerOfTwo": function () {},
    "clamp": function () {},
    "degToRad": function () {},
    "euclideanModulo": function () {},
    "floorPowerOfTwo": function () {},
    "generateUUID": function () {},
    "isPowerOfTwo": function () {},
    "lerp": function () {},
    "mapLinear": function () {},
    "nearestPowerOfTwo": function () {},
    "nextPowerOfTwo": function () {},
    "radToDeg": function () {},
    "randFloat": function () {},
    "randFloatSpread": function () {},
    "randInt": function () {},
    "random16": function () {},
    "smootherstep": function () {},
    "smoothstep": function () {}
  },
  "Matrix3": function () {},
  "Matrix4": function () {},
  "MaxEquation": {},
  "Mesh": function () {},
  "MeshBasicMaterial": function () {},
  "MeshDepthMaterial": function () {},
  "MeshDistanceMaterial": function () {},
  "MeshFaceMaterial": function () {},
  "MeshLambertMaterial": function () {},
  "MeshNormalMaterial": function () {},
  "MeshPhongMaterial": function () {},
  "MeshPhysicalMaterial": function () {},
  "MeshStandardMaterial": function () {},
  "MeshToonMaterial": function () {},
  "MinEquation": {},
  "MirroredRepeatWrapping": {},
  "MixOperation": {},
  "MultiMaterial": function () {},
  "MultiplyBlending": {},
  "MultiplyOperation": {},
  "NearestFilter": {},
  "NearestMipMapLinearFilter": {},
  "NearestMipMapNearestFilter": {},
  "NeverDepth": {},
  "NoBlending": {},
  "NoColors": {},
  "NoToneMapping": {},
  "NormalBlending": {},
  "NotEqualDepth": {},
  "NumberKeyframeTrack": function () {},
  "Object3D": {
    "DefaultMatrixAutoUpdate": {},
    "DefaultUp": {
      "add": function () {},
      "addScalar": function () {},
      "addScaledVector": function () {},
      "addVectors": function () {},
      "angleTo": function () {},
      "applyAxisAngle": function () {},
      "applyEuler": function () {},
      "applyMatrix3": function () {},
      "applyMatrix4": function () {},
      "applyProjection": function () {},
      "applyQuaternion": function () {},
      "ceil": function () {},
      "clamp": function () {},
      "clampLength": function () {},
      "clampScalar": function () {},
      "clone": function () {},
      "copy": function () {},
      "cross": function () {},
      "crossVectors": function () {},
      "distanceTo": function () {},
      "distanceToManhattan": function () {},
      "distanceToSquared": function () {},
      "divide": function () {},
      "divideScalar": function () {},
      "dot": function () {},
      "equals": function () {},
      "floor": function () {},
      "fromArray": function () {},
      "fromAttribute": function () {},
      "fromBufferAttribute": function () {},
      "getColumnFromMatrix": function () {},
      "getComponent": function () {},
      "getPositionFromMatrix": function () {},
      "getScaleFromMatrix": function () {},
      "isVector3": {},
      "length": function () {},
      "lengthManhattan": function () {},
      "lengthSq": function () {},
      "lerp": function () {},
      "lerpVectors": function () {},
      "manhattanDistanceTo": function () {},
      "manhattanLength": function () {},
      "max": function () {},
      "min": function () {},
      "multiply": function () {},
      "multiplyScalar": function () {},
      "multiplyVectors": function () {},
      "negate": function () {},
      "normalize": function () {},
      "project": function () {},
      "projectOnPlane": function () {},
      "projectOnVector": function () {},
      "reflect": function () {},
      "round": function () {},
      "roundToZero": function () {},
      "set": function () {},
      "setComponent": function () {},
      "setEulerFromQuaternion": function () {},
      "setEulerFromRotationMatrix": function () {},
      "setFromCylindrical": function () {},
      "setFromMatrixColumn": function () {},
      "setFromMatrixPosition": function () {},
      "setFromMatrixScale": function () {},
      "setFromSpherical": function () {},
      "setLength": function () {},
      "setScalar": function () {},
      "setX": function () {},
      "setY": function () {},
      "setZ": function () {},
      "sub": function () {},
      "subScalar": function () {},
      "subVectors": function () {},
      "toArray": function () {},
      "transformDirection": function () {},
      "unproject": function () {},
      "x": {},
      "y": {},
      "z": {}
    }
  },
  "ObjectLoader": function () {},
  "OctahedronBufferGeometry": function () {},
  "OctahedronGeometry": function () {},
  "OneFactor": {},
  "OneMinusDstAlphaFactor": {},
  "OneMinusDstColorFactor": {},
  "OneMinusSrcAlphaFactor": {},
  "OneMinusSrcColorFactor": {},
  "OrthographicCamera": function () {},
  "PCFShadowMap": {},
  "PCFSoftShadowMap": {},
  "ParametricBufferGeometry": function () {},
  "ParametricGeometry": function () {},
  "Particle": function () {},
  "ParticleBasicMaterial": function () {},
  "ParticleSystem": function () {},
  "ParticleSystemMaterial": function () {},
  "Path": function () {},
  "PerspectiveCamera": function () {},
  "Plane": function () {},
  "PlaneBufferGeometry": function () {},
  "PlaneGeometry": function () {},
  "PlaneHelper": function () {},
  "PointCloud": function () {},
  "PointCloudMaterial": function () {},
  "PointLight": function () {},
  "PointLightHelper": function () {},
  "Points": function () {},
  "PointsMaterial": function () {},
  "PolarGridHelper": function () {},
  "PolyhedronBufferGeometry": function () {},
  "PolyhedronGeometry": function () {},
  "PositionalAudio": function () {},
  "Projector": function () {},
  "PropertyBinding": {
    "Composite": function () {},
    "create": function () {},
    "findNode": function () {},
    "parseTrackName": function () {},
    "sanitizeNodeName": function () {}
  },
  "PropertyMixer": function () {},
  "QuadraticBezierCurve": function () {},
  "QuadraticBezierCurve3": function () {},
  "Quaternion": {
    "slerp": function () {},
    "slerpFlat": function () {}
  },
  "QuaternionKeyframeTrack": function () {},
  "QuaternionLinearInterpolant": function () {},
  "REVISION": {},
  "RGBADepthPacking": {},
  "RGBAFormat": {},
  "RGBA_PVRTC_2BPPV1_Format": {},
  "RGBA_PVRTC_4BPPV1_Format": {},
  "RGBA_S3TC_DXT1_Format": {},
  "RGBA_S3TC_DXT3_Format": {},
  "RGBA_S3TC_DXT5_Format": {},
  "RGBDEncoding": {},
  "RGBEEncoding": {},
  "RGBEFormat": {},
  "RGBFormat": {},
  "RGBM16Encoding": {},
  "RGBM7Encoding": {},
  "RGB_ETC1_Format": {},
  "RGB_PVRTC_2BPPV1_Format": {},
  "RGB_PVRTC_4BPPV1_Format": {},
  "RGB_S3TC_DXT1_Format": {},
  "RawShaderMaterial": function () {},
  "Ray": function () {},
  "Raycaster": function () {},
  "RectAreaLight": function () {},
  "RectAreaLightHelper": function () {},
  "ReinhardToneMapping": {},
  "RepeatWrapping": {},
  "ReverseSubtractEquation": {},
  "RingBufferGeometry": function () {},
  "RingGeometry": function () {},
  "Scene": function () {},
  "SceneUtils": {
    "attach": function () {},
    "createMultiMaterialObject": function () {},
    "detach": function () {}
  },
  "ShaderChunk": {
    "alphamap_fragment": {},
    "alphamap_pars_fragment": {},
    "alphatest_fragment": {},
    "aomap_fragment": {},
    "aomap_pars_fragment": {},
    "begin_vertex": {},
    "beginnormal_vertex": {},
    "bsdfs": {},
    "bumpmap_pars_fragment": {},
    "clipping_planes_fragment": {},
    "clipping_planes_pars_fragment": {},
    "clipping_planes_pars_vertex": {},
    "clipping_planes_vertex": {},
    "color_fragment": {},
    "color_pars_fragment": {},
    "color_pars_vertex": {},
    "color_vertex": {},
    "common": {},
    "cube_frag": {},
    "cube_uv_reflection_fragment": {},
    "cube_vert": {},
    "defaultnormal_vertex": {},
    "depth_frag": {},
    "depth_vert": {},
    "displacementmap_pars_vertex": {},
    "displacementmap_vertex": {},
    "distanceRGBA_frag": {},
    "distanceRGBA_vert": {},
    "dithering_fragment": {},
    "dithering_pars_fragment": {},
    "emissivemap_fragment": {},
    "emissivemap_pars_fragment": {},
    "encodings_fragment": {},
    "encodings_pars_fragment": {},
    "envmap_fragment": {},
    "envmap_pars_fragment": {},
    "envmap_pars_vertex": {},
    "envmap_vertex": {},
    "equirect_frag": {},
    "equirect_vert": {},
    "fog_fragment": {},
    "fog_pars_fragment": {},
    "fog_pars_vertex": {},
    "fog_vertex": {},
    "gradientmap_pars_fragment": {},
    "lightmap_fragment": {},
    "lightmap_pars_fragment": {},
    "lights_lambert_vertex": {},
    "lights_pars": {},
    "lights_phong_fragment": {},
    "lights_phong_pars_fragment": {},
    "lights_physical_fragment": {},
    "lights_physical_pars_fragment": {},
    "lights_template": {},
    "linedashed_frag": {},
    "linedashed_vert": {},
    "logdepthbuf_fragment": {},
    "logdepthbuf_pars_fragment": {},
    "logdepthbuf_pars_vertex": {},
    "logdepthbuf_vertex": {},
    "map_fragment": {},
    "map_pars_fragment": {},
    "map_particle_fragment": {},
    "map_particle_pars_fragment": {},
    "meshbasic_frag": {},
    "meshbasic_vert": {},
    "meshlambert_frag": {},
    "meshlambert_vert": {},
    "meshphong_frag": {},
    "meshphong_vert": {},
    "meshphysical_frag": {},
    "meshphysical_vert": {},
    "metalnessmap_fragment": {},
    "metalnessmap_pars_fragment": {},
    "morphnormal_vertex": {},
    "morphtarget_pars_vertex": {},
    "morphtarget_vertex": {},
    "normal_frag": {},
    "normal_fragment": {},
    "normal_vert": {},
    "normalmap_pars_fragment": {},
    "packing": {},
    "points_frag": {},
    "points_vert": {},
    "premultiplied_alpha_fragment": {},
    "project_vertex": {},
    "roughnessmap_fragment": {},
    "roughnessmap_pars_fragment": {},
    "shadow_frag": {},
    "shadow_vert": {},
    "shadowmap_pars_fragment": {},
    "shadowmap_pars_vertex": {},
    "shadowmap_vertex": {},
    "shadowmask_pars_fragment": {},
    "skinbase_vertex": {},
    "skinning_pars_vertex": {},
    "skinning_vertex": {},
    "skinnormal_vertex": {},
    "specularmap_fragment": {},
    "specularmap_pars_fragment": {},
    "tonemapping_fragment": {},
    "tonemapping_pars_fragment": {},
    "uv2_pars_fragment": {},
    "uv2_pars_vertex": {},
    "uv2_vertex": {},
    "uv_pars_fragment": {},
    "uv_pars_vertex": {},
    "uv_vertex": {},
    "worldpos_vertex": {}
  },
  "ShaderLib": {
    "basic": {
      "fragmentShader": {},
      "uniforms": {
        "alphaMap": {
          "value": {}
        },
        "aoMap": {
          "value": {}
        },
        "aoMapIntensity": {
          "value": {}
        },
        "diffuse": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "envMap": {
          "value": {}
        },
        "flipEnvMap": {
          "value": {}
        },
        "fogColor": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "fogDensity": {
          "value": {}
        },
        "fogFar": {
          "value": {}
        },
        "fogNear": {
          "value": {}
        },
        "lightMap": {
          "value": {}
        },
        "lightMapIntensity": {
          "value": {}
        },
        "map": {
          "value": {}
        },
        "opacity": {
          "value": {}
        },
        "reflectivity": {
          "value": {}
        },
        "refractionRatio": {
          "value": {}
        },
        "specularMap": {
          "value": {}
        },
        "uvTransform": {
          "value": {
            "applyToBuffer": function () {},
            "applyToBufferAttribute": function () {},
            "applyToVector3Array": function () {},
            "clone": function () {},
            "copy": function () {},
            "determinant": function () {},
            "elements": {},
            "equals": function () {},
            "flattenToArrayOffset": function () {},
            "fromArray": function () {},
            "getInverse": function () {},
            "getNormalMatrix": function () {},
            "identity": function () {},
            "isMatrix3": {},
            "multiply": function () {},
            "multiplyMatrices": function () {},
            "multiplyScalar": function () {},
            "multiplyVector3": function () {},
            "multiplyVector3Array": function () {},
            "premultiply": function () {},
            "rotate": function () {},
            "scale": function () {},
            "set": function () {},
            "setFromMatrix4": function () {},
            "setUvTransform": function () {},
            "toArray": function () {},
            "translate": function () {},
            "transpose": function () {},
            "transposeIntoArray": function () {}
          }
        }
      },
      "vertexShader": {}
    },
    "cube": {
      "fragmentShader": {},
      "uniforms": {
        "opacity": {
          "value": {}
        },
        "tCube": {
          "value": {}
        },
        "tFlip": {
          "value": {}
        }
      },
      "vertexShader": {}
    },
    "dashed": {
      "fragmentShader": {},
      "uniforms": {
        "alphaMap": {
          "value": {}
        },
        "dashSize": {
          "value": {}
        },
        "diffuse": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "fogColor": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "fogDensity": {
          "value": {}
        },
        "fogFar": {
          "value": {}
        },
        "fogNear": {
          "value": {}
        },
        "map": {
          "value": {}
        },
        "opacity": {
          "value": {}
        },
        "scale": {
          "value": {}
        },
        "totalSize": {
          "value": {}
        },
        "uvTransform": {
          "value": {
            "applyToBuffer": function () {},
            "applyToBufferAttribute": function () {},
            "applyToVector3Array": function () {},
            "clone": function () {},
            "copy": function () {},
            "determinant": function () {},
            "elements": {},
            "equals": function () {},
            "flattenToArrayOffset": function () {},
            "fromArray": function () {},
            "getInverse": function () {},
            "getNormalMatrix": function () {},
            "identity": function () {},
            "isMatrix3": {},
            "multiply": function () {},
            "multiplyMatrices": function () {},
            "multiplyScalar": function () {},
            "multiplyVector3": function () {},
            "multiplyVector3Array": function () {},
            "premultiply": function () {},
            "rotate": function () {},
            "scale": function () {},
            "set": function () {},
            "setFromMatrix4": function () {},
            "setUvTransform": function () {},
            "toArray": function () {},
            "translate": function () {},
            "transpose": function () {},
            "transposeIntoArray": function () {}
          }
        }
      },
      "vertexShader": {}
    },
    "depth": {
      "fragmentShader": {},
      "uniforms": {
        "alphaMap": {
          "value": {}
        },
        "diffuse": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "displacementBias": {
          "value": {}
        },
        "displacementMap": {
          "value": {}
        },
        "displacementScale": {
          "value": {}
        },
        "map": {
          "value": {}
        },
        "opacity": {
          "value": {}
        },
        "uvTransform": {
          "value": {
            "applyToBuffer": function () {},
            "applyToBufferAttribute": function () {},
            "applyToVector3Array": function () {},
            "clone": function () {},
            "copy": function () {},
            "determinant": function () {},
            "elements": {},
            "equals": function () {},
            "flattenToArrayOffset": function () {},
            "fromArray": function () {},
            "getInverse": function () {},
            "getNormalMatrix": function () {},
            "identity": function () {},
            "isMatrix3": {},
            "multiply": function () {},
            "multiplyMatrices": function () {},
            "multiplyScalar": function () {},
            "multiplyVector3": function () {},
            "multiplyVector3Array": function () {},
            "premultiply": function () {},
            "rotate": function () {},
            "scale": function () {},
            "set": function () {},
            "setFromMatrix4": function () {},
            "setUvTransform": function () {},
            "toArray": function () {},
            "translate": function () {},
            "transpose": function () {},
            "transposeIntoArray": function () {}
          }
        }
      },
      "vertexShader": {}
    },
    "distanceRGBA": {
      "fragmentShader": {},
      "uniforms": {
        "alphaMap": {
          "value": {}
        },
        "diffuse": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "displacementBias": {
          "value": {}
        },
        "displacementMap": {
          "value": {}
        },
        "displacementScale": {
          "value": {}
        },
        "farDistance": {
          "value": {}
        },
        "map": {
          "value": {}
        },
        "nearDistance": {
          "value": {}
        },
        "opacity": {
          "value": {}
        },
        "referencePosition": {
          "value": {
            "add": function () {},
            "addScalar": function () {},
            "addScaledVector": function () {},
            "addVectors": function () {},
            "angleTo": function () {},
            "applyAxisAngle": function () {},
            "applyEuler": function () {},
            "applyMatrix3": function () {},
            "applyMatrix4": function () {},
            "applyProjection": function () {},
            "applyQuaternion": function () {},
            "ceil": function () {},
            "clamp": function () {},
            "clampLength": function () {},
            "clampScalar": function () {},
            "clone": function () {},
            "copy": function () {},
            "cross": function () {},
            "crossVectors": function () {},
            "distanceTo": function () {},
            "distanceToManhattan": function () {},
            "distanceToSquared": function () {},
            "divide": function () {},
            "divideScalar": function () {},
            "dot": function () {},
            "equals": function () {},
            "floor": function () {},
            "fromArray": function () {},
            "fromAttribute": function () {},
            "fromBufferAttribute": function () {},
            "getColumnFromMatrix": function () {},
            "getComponent": function () {},
            "getPositionFromMatrix": function () {},
            "getScaleFromMatrix": function () {},
            "isVector3": {},
            "length": function () {},
            "lengthManhattan": function () {},
            "lengthSq": function () {},
            "lerp": function () {},
            "lerpVectors": function () {},
            "manhattanDistanceTo": function () {},
            "manhattanLength": function () {},
            "max": function () {},
            "min": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "multiplyVectors": function () {},
            "negate": function () {},
            "normalize": function () {},
            "project": function () {},
            "projectOnPlane": function () {},
            "projectOnVector": function () {},
            "reflect": function () {},
            "round": function () {},
            "roundToZero": function () {},
            "set": function () {},
            "setComponent": function () {},
            "setEulerFromQuaternion": function () {},
            "setEulerFromRotationMatrix": function () {},
            "setFromCylindrical": function () {},
            "setFromMatrixColumn": function () {},
            "setFromMatrixPosition": function () {},
            "setFromMatrixScale": function () {},
            "setFromSpherical": function () {},
            "setLength": function () {},
            "setScalar": function () {},
            "setX": function () {},
            "setY": function () {},
            "setZ": function () {},
            "sub": function () {},
            "subScalar": function () {},
            "subVectors": function () {},
            "toArray": function () {},
            "transformDirection": function () {},
            "unproject": function () {},
            "x": {},
            "y": {},
            "z": {}
          }
        },
        "uvTransform": {
          "value": {
            "applyToBuffer": function () {},
            "applyToBufferAttribute": function () {},
            "applyToVector3Array": function () {},
            "clone": function () {},
            "copy": function () {},
            "determinant": function () {},
            "elements": {},
            "equals": function () {},
            "flattenToArrayOffset": function () {},
            "fromArray": function () {},
            "getInverse": function () {},
            "getNormalMatrix": function () {},
            "identity": function () {},
            "isMatrix3": {},
            "multiply": function () {},
            "multiplyMatrices": function () {},
            "multiplyScalar": function () {},
            "multiplyVector3": function () {},
            "multiplyVector3Array": function () {},
            "premultiply": function () {},
            "rotate": function () {},
            "scale": function () {},
            "set": function () {},
            "setFromMatrix4": function () {},
            "setUvTransform": function () {},
            "toArray": function () {},
            "translate": function () {},
            "transpose": function () {},
            "transposeIntoArray": function () {}
          }
        }
      },
      "vertexShader": {}
    },
    "equirect": {
      "fragmentShader": {},
      "uniforms": {
        "tEquirect": {
          "value": {}
        }
      },
      "vertexShader": {}
    },
    "lambert": {
      "fragmentShader": {},
      "uniforms": {
        "alphaMap": {
          "value": {}
        },
        "ambientLightColor": {
          "value": {}
        },
        "aoMap": {
          "value": {}
        },
        "aoMapIntensity": {
          "value": {}
        },
        "diffuse": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "directionalLights": {
          "properties": {
            "color": {},
            "direction": {},
            "shadow": {},
            "shadowBias": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "directionalShadowMap": {
          "value": {}
        },
        "directionalShadowMatrix": {
          "value": {}
        },
        "emissive": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "emissiveMap": {
          "value": {}
        },
        "envMap": {
          "value": {}
        },
        "flipEnvMap": {
          "value": {}
        },
        "fogColor": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "fogDensity": {
          "value": {}
        },
        "fogFar": {
          "value": {}
        },
        "fogNear": {
          "value": {}
        },
        "hemisphereLights": {
          "properties": {
            "direction": {},
            "groundColor": {},
            "skyColor": {}
          },
          "value": {}
        },
        "lightMap": {
          "value": {}
        },
        "lightMapIntensity": {
          "value": {}
        },
        "map": {
          "value": {}
        },
        "opacity": {
          "value": {}
        },
        "pointLights": {
          "properties": {
            "color": {},
            "decay": {},
            "distance": {},
            "position": {},
            "shadow": {},
            "shadowBias": {},
            "shadowCameraFar": {},
            "shadowCameraNear": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "pointShadowMap": {
          "value": {}
        },
        "pointShadowMatrix": {
          "value": {}
        },
        "rectAreaLights": {
          "properties": {
            "color": {},
            "height": {},
            "position": {},
            "width": {}
          },
          "value": {}
        },
        "reflectivity": {
          "value": {}
        },
        "refractionRatio": {
          "value": {}
        },
        "specularMap": {
          "value": {}
        },
        "spotLights": {
          "properties": {
            "color": {},
            "coneCos": {},
            "decay": {},
            "direction": {},
            "distance": {},
            "penumbraCos": {},
            "position": {},
            "shadow": {},
            "shadowBias": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "spotShadowMap": {
          "value": {}
        },
        "spotShadowMatrix": {
          "value": {}
        },
        "uvTransform": {
          "value": {
            "applyToBuffer": function () {},
            "applyToBufferAttribute": function () {},
            "applyToVector3Array": function () {},
            "clone": function () {},
            "copy": function () {},
            "determinant": function () {},
            "elements": {},
            "equals": function () {},
            "flattenToArrayOffset": function () {},
            "fromArray": function () {},
            "getInverse": function () {},
            "getNormalMatrix": function () {},
            "identity": function () {},
            "isMatrix3": {},
            "multiply": function () {},
            "multiplyMatrices": function () {},
            "multiplyScalar": function () {},
            "multiplyVector3": function () {},
            "multiplyVector3Array": function () {},
            "premultiply": function () {},
            "rotate": function () {},
            "scale": function () {},
            "set": function () {},
            "setFromMatrix4": function () {},
            "setUvTransform": function () {},
            "toArray": function () {},
            "translate": function () {},
            "transpose": function () {},
            "transposeIntoArray": function () {}
          }
        }
      },
      "vertexShader": {}
    },
    "normal": {
      "fragmentShader": {},
      "uniforms": {
        "alphaMap": {
          "value": {}
        },
        "bumpMap": {
          "value": {}
        },
        "bumpScale": {
          "value": {}
        },
        "diffuse": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "displacementBias": {
          "value": {}
        },
        "displacementMap": {
          "value": {}
        },
        "displacementScale": {
          "value": {}
        },
        "map": {
          "value": {}
        },
        "normalMap": {
          "value": {}
        },
        "normalScale": {
          "value": {
            "add": function () {},
            "addScalar": function () {},
            "addScaledVector": function () {},
            "addVectors": function () {},
            "angle": function () {},
            "applyMatrix3": function () {},
            "ceil": function () {},
            "clamp": function () {},
            "clampLength": function () {},
            "clampScalar": function () {},
            "clone": function () {},
            "copy": function () {},
            "distanceTo": function () {},
            "distanceToManhattan": function () {},
            "distanceToSquared": function () {},
            "divide": function () {},
            "divideScalar": function () {},
            "dot": function () {},
            "equals": function () {},
            "floor": function () {},
            "fromArray": function () {},
            "fromAttribute": function () {},
            "fromBufferAttribute": function () {},
            "getComponent": function () {},
            "isVector2": {},
            "length": function () {},
            "lengthManhattan": function () {},
            "lengthSq": function () {},
            "lerp": function () {},
            "lerpVectors": function () {},
            "manhattanDistanceTo": function () {},
            "manhattanLength": function () {},
            "max": function () {},
            "min": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "negate": function () {},
            "normalize": function () {},
            "rotateAround": function () {},
            "round": function () {},
            "roundToZero": function () {},
            "set": function () {},
            "setComponent": function () {},
            "setLength": function () {},
            "setScalar": function () {},
            "setX": function () {},
            "setY": function () {},
            "sub": function () {},
            "subScalar": function () {},
            "subVectors": function () {},
            "toArray": function () {},
            "x": {},
            "y": {}
          }
        },
        "opacity": {
          "value": {}
        },
        "uvTransform": {
          "value": {
            "applyToBuffer": function () {},
            "applyToBufferAttribute": function () {},
            "applyToVector3Array": function () {},
            "clone": function () {},
            "copy": function () {},
            "determinant": function () {},
            "elements": {},
            "equals": function () {},
            "flattenToArrayOffset": function () {},
            "fromArray": function () {},
            "getInverse": function () {},
            "getNormalMatrix": function () {},
            "identity": function () {},
            "isMatrix3": {},
            "multiply": function () {},
            "multiplyMatrices": function () {},
            "multiplyScalar": function () {},
            "multiplyVector3": function () {},
            "multiplyVector3Array": function () {},
            "premultiply": function () {},
            "rotate": function () {},
            "scale": function () {},
            "set": function () {},
            "setFromMatrix4": function () {},
            "setUvTransform": function () {},
            "toArray": function () {},
            "translate": function () {},
            "transpose": function () {},
            "transposeIntoArray": function () {}
          }
        }
      },
      "vertexShader": {}
    },
    "phong": {
      "fragmentShader": {},
      "uniforms": {
        "alphaMap": {
          "value": {}
        },
        "ambientLightColor": {
          "value": {}
        },
        "aoMap": {
          "value": {}
        },
        "aoMapIntensity": {
          "value": {}
        },
        "bumpMap": {
          "value": {}
        },
        "bumpScale": {
          "value": {}
        },
        "diffuse": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "directionalLights": {
          "properties": {
            "color": {},
            "direction": {},
            "shadow": {},
            "shadowBias": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "directionalShadowMap": {
          "value": {}
        },
        "directionalShadowMatrix": {
          "value": {}
        },
        "displacementBias": {
          "value": {}
        },
        "displacementMap": {
          "value": {}
        },
        "displacementScale": {
          "value": {}
        },
        "emissive": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "emissiveMap": {
          "value": {}
        },
        "envMap": {
          "value": {}
        },
        "flipEnvMap": {
          "value": {}
        },
        "fogColor": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "fogDensity": {
          "value": {}
        },
        "fogFar": {
          "value": {}
        },
        "fogNear": {
          "value": {}
        },
        "gradientMap": {
          "value": {}
        },
        "hemisphereLights": {
          "properties": {
            "direction": {},
            "groundColor": {},
            "skyColor": {}
          },
          "value": {}
        },
        "lightMap": {
          "value": {}
        },
        "lightMapIntensity": {
          "value": {}
        },
        "map": {
          "value": {}
        },
        "normalMap": {
          "value": {}
        },
        "normalScale": {
          "value": {
            "add": function () {},
            "addScalar": function () {},
            "addScaledVector": function () {},
            "addVectors": function () {},
            "angle": function () {},
            "applyMatrix3": function () {},
            "ceil": function () {},
            "clamp": function () {},
            "clampLength": function () {},
            "clampScalar": function () {},
            "clone": function () {},
            "copy": function () {},
            "distanceTo": function () {},
            "distanceToManhattan": function () {},
            "distanceToSquared": function () {},
            "divide": function () {},
            "divideScalar": function () {},
            "dot": function () {},
            "equals": function () {},
            "floor": function () {},
            "fromArray": function () {},
            "fromAttribute": function () {},
            "fromBufferAttribute": function () {},
            "getComponent": function () {},
            "isVector2": {},
            "length": function () {},
            "lengthManhattan": function () {},
            "lengthSq": function () {},
            "lerp": function () {},
            "lerpVectors": function () {},
            "manhattanDistanceTo": function () {},
            "manhattanLength": function () {},
            "max": function () {},
            "min": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "negate": function () {},
            "normalize": function () {},
            "rotateAround": function () {},
            "round": function () {},
            "roundToZero": function () {},
            "set": function () {},
            "setComponent": function () {},
            "setLength": function () {},
            "setScalar": function () {},
            "setX": function () {},
            "setY": function () {},
            "sub": function () {},
            "subScalar": function () {},
            "subVectors": function () {},
            "toArray": function () {},
            "x": {},
            "y": {}
          }
        },
        "opacity": {
          "value": {}
        },
        "pointLights": {
          "properties": {
            "color": {},
            "decay": {},
            "distance": {},
            "position": {},
            "shadow": {},
            "shadowBias": {},
            "shadowCameraFar": {},
            "shadowCameraNear": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "pointShadowMap": {
          "value": {}
        },
        "pointShadowMatrix": {
          "value": {}
        },
        "rectAreaLights": {
          "properties": {
            "color": {},
            "height": {},
            "position": {},
            "width": {}
          },
          "value": {}
        },
        "reflectivity": {
          "value": {}
        },
        "refractionRatio": {
          "value": {}
        },
        "shininess": {
          "value": {}
        },
        "specular": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "specularMap": {
          "value": {}
        },
        "spotLights": {
          "properties": {
            "color": {},
            "coneCos": {},
            "decay": {},
            "direction": {},
            "distance": {},
            "penumbraCos": {},
            "position": {},
            "shadow": {},
            "shadowBias": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "spotShadowMap": {
          "value": {}
        },
        "spotShadowMatrix": {
          "value": {}
        },
        "uvTransform": {
          "value": {
            "applyToBuffer": function () {},
            "applyToBufferAttribute": function () {},
            "applyToVector3Array": function () {},
            "clone": function () {},
            "copy": function () {},
            "determinant": function () {},
            "elements": {},
            "equals": function () {},
            "flattenToArrayOffset": function () {},
            "fromArray": function () {},
            "getInverse": function () {},
            "getNormalMatrix": function () {},
            "identity": function () {},
            "isMatrix3": {},
            "multiply": function () {},
            "multiplyMatrices": function () {},
            "multiplyScalar": function () {},
            "multiplyVector3": function () {},
            "multiplyVector3Array": function () {},
            "premultiply": function () {},
            "rotate": function () {},
            "scale": function () {},
            "set": function () {},
            "setFromMatrix4": function () {},
            "setUvTransform": function () {},
            "toArray": function () {},
            "translate": function () {},
            "transpose": function () {},
            "transposeIntoArray": function () {}
          }
        }
      },
      "vertexShader": {}
    },
    "physical": {
      "fragmentShader": {},
      "uniforms": {
        "alphaMap": {
          "value": {}
        },
        "ambientLightColor": {
          "value": {}
        },
        "aoMap": {
          "value": {}
        },
        "aoMapIntensity": {
          "value": {}
        },
        "bumpMap": {
          "value": {}
        },
        "bumpScale": {
          "value": {}
        },
        "clearCoat": {
          "value": {}
        },
        "clearCoatRoughness": {
          "value": {}
        },
        "diffuse": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "directionalLights": {
          "properties": {
            "color": {},
            "direction": {},
            "shadow": {},
            "shadowBias": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "directionalShadowMap": {
          "value": {}
        },
        "directionalShadowMatrix": {
          "value": {}
        },
        "displacementBias": {
          "value": {}
        },
        "displacementMap": {
          "value": {}
        },
        "displacementScale": {
          "value": {}
        },
        "emissive": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "emissiveMap": {
          "value": {}
        },
        "envMap": {
          "value": {}
        },
        "envMapIntensity": {
          "value": {}
        },
        "flipEnvMap": {
          "value": {}
        },
        "fogColor": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "fogDensity": {
          "value": {}
        },
        "fogFar": {
          "value": {}
        },
        "fogNear": {
          "value": {}
        },
        "hemisphereLights": {
          "properties": {
            "direction": {},
            "groundColor": {},
            "skyColor": {}
          },
          "value": {}
        },
        "lightMap": {
          "value": {}
        },
        "lightMapIntensity": {
          "value": {}
        },
        "map": {
          "value": {}
        },
        "metalness": {
          "value": {}
        },
        "metalnessMap": {
          "value": {}
        },
        "normalMap": {
          "value": {}
        },
        "normalScale": {
          "value": {
            "add": function () {},
            "addScalar": function () {},
            "addScaledVector": function () {},
            "addVectors": function () {},
            "angle": function () {},
            "applyMatrix3": function () {},
            "ceil": function () {},
            "clamp": function () {},
            "clampLength": function () {},
            "clampScalar": function () {},
            "clone": function () {},
            "copy": function () {},
            "distanceTo": function () {},
            "distanceToManhattan": function () {},
            "distanceToSquared": function () {},
            "divide": function () {},
            "divideScalar": function () {},
            "dot": function () {},
            "equals": function () {},
            "floor": function () {},
            "fromArray": function () {},
            "fromAttribute": function () {},
            "fromBufferAttribute": function () {},
            "getComponent": function () {},
            "isVector2": {},
            "length": function () {},
            "lengthManhattan": function () {},
            "lengthSq": function () {},
            "lerp": function () {},
            "lerpVectors": function () {},
            "manhattanDistanceTo": function () {},
            "manhattanLength": function () {},
            "max": function () {},
            "min": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "negate": function () {},
            "normalize": function () {},
            "rotateAround": function () {},
            "round": function () {},
            "roundToZero": function () {},
            "set": function () {},
            "setComponent": function () {},
            "setLength": function () {},
            "setScalar": function () {},
            "setX": function () {},
            "setY": function () {},
            "sub": function () {},
            "subScalar": function () {},
            "subVectors": function () {},
            "toArray": function () {},
            "x": {},
            "y": {}
          }
        },
        "opacity": {
          "value": {}
        },
        "pointLights": {
          "properties": {
            "color": {},
            "decay": {},
            "distance": {},
            "position": {},
            "shadow": {},
            "shadowBias": {},
            "shadowCameraFar": {},
            "shadowCameraNear": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "pointShadowMap": {
          "value": {}
        },
        "pointShadowMatrix": {
          "value": {}
        },
        "rectAreaLights": {
          "properties": {
            "color": {},
            "height": {},
            "position": {},
            "width": {}
          },
          "value": {}
        },
        "reflectivity": {
          "value": {}
        },
        "refractionRatio": {
          "value": {}
        },
        "roughness": {
          "value": {}
        },
        "roughnessMap": {
          "value": {}
        },
        "spotLights": {
          "properties": {
            "color": {},
            "coneCos": {},
            "decay": {},
            "direction": {},
            "distance": {},
            "penumbraCos": {},
            "position": {},
            "shadow": {},
            "shadowBias": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "spotShadowMap": {
          "value": {}
        },
        "spotShadowMatrix": {
          "value": {}
        },
        "uvTransform": {
          "value": {
            "applyToBuffer": function () {},
            "applyToBufferAttribute": function () {},
            "applyToVector3Array": function () {},
            "clone": function () {},
            "copy": function () {},
            "determinant": function () {},
            "elements": {},
            "equals": function () {},
            "flattenToArrayOffset": function () {},
            "fromArray": function () {},
            "getInverse": function () {},
            "getNormalMatrix": function () {},
            "identity": function () {},
            "isMatrix3": {},
            "multiply": function () {},
            "multiplyMatrices": function () {},
            "multiplyScalar": function () {},
            "multiplyVector3": function () {},
            "multiplyVector3Array": function () {},
            "premultiply": function () {},
            "rotate": function () {},
            "scale": function () {},
            "set": function () {},
            "setFromMatrix4": function () {},
            "setUvTransform": function () {},
            "toArray": function () {},
            "translate": function () {},
            "transpose": function () {},
            "transposeIntoArray": function () {}
          }
        }
      },
      "vertexShader": {}
    },
    "points": {
      "fragmentShader": {},
      "uniforms": {
        "diffuse": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "fogColor": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "fogDensity": {
          "value": {}
        },
        "fogFar": {
          "value": {}
        },
        "fogNear": {
          "value": {}
        },
        "map": {
          "value": {}
        },
        "opacity": {
          "value": {}
        },
        "scale": {
          "value": {}
        },
        "size": {
          "value": {}
        },
        "uvTransform": {
          "value": {
            "applyToBuffer": function () {},
            "applyToBufferAttribute": function () {},
            "applyToVector3Array": function () {},
            "clone": function () {},
            "copy": function () {},
            "determinant": function () {},
            "elements": {},
            "equals": function () {},
            "flattenToArrayOffset": function () {},
            "fromArray": function () {},
            "getInverse": function () {},
            "getNormalMatrix": function () {},
            "identity": function () {},
            "isMatrix3": {},
            "multiply": function () {},
            "multiplyMatrices": function () {},
            "multiplyScalar": function () {},
            "multiplyVector3": function () {},
            "multiplyVector3Array": function () {},
            "premultiply": function () {},
            "rotate": function () {},
            "scale": function () {},
            "set": function () {},
            "setFromMatrix4": function () {},
            "setUvTransform": function () {},
            "toArray": function () {},
            "translate": function () {},
            "transpose": function () {},
            "transposeIntoArray": function () {}
          }
        }
      },
      "vertexShader": {}
    },
    "shadow": {
      "fragmentShader": {},
      "uniforms": {
        "ambientLightColor": {
          "value": {}
        },
        "color": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "directionalLights": {
          "properties": {
            "color": {},
            "direction": {},
            "shadow": {},
            "shadowBias": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "directionalShadowMap": {
          "value": {}
        },
        "directionalShadowMatrix": {
          "value": {}
        },
        "fogColor": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "fogDensity": {
          "value": {}
        },
        "fogFar": {
          "value": {}
        },
        "fogNear": {
          "value": {}
        },
        "hemisphereLights": {
          "properties": {
            "direction": {},
            "groundColor": {},
            "skyColor": {}
          },
          "value": {}
        },
        "opacity": {
          "value": {}
        },
        "pointLights": {
          "properties": {
            "color": {},
            "decay": {},
            "distance": {},
            "position": {},
            "shadow": {},
            "shadowBias": {},
            "shadowCameraFar": {},
            "shadowCameraNear": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "pointShadowMap": {
          "value": {}
        },
        "pointShadowMatrix": {
          "value": {}
        },
        "rectAreaLights": {
          "properties": {
            "color": {},
            "height": {},
            "position": {},
            "width": {}
          },
          "value": {}
        },
        "spotLights": {
          "properties": {
            "color": {},
            "coneCos": {},
            "decay": {},
            "direction": {},
            "distance": {},
            "penumbraCos": {},
            "position": {},
            "shadow": {},
            "shadowBias": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "spotShadowMap": {
          "value": {}
        },
        "spotShadowMatrix": {
          "value": {}
        }
      },
      "vertexShader": {}
    },
    "standard": {
      "fragmentShader": {},
      "uniforms": {
        "alphaMap": {
          "value": {}
        },
        "ambientLightColor": {
          "value": {}
        },
        "aoMap": {
          "value": {}
        },
        "aoMapIntensity": {
          "value": {}
        },
        "bumpMap": {
          "value": {}
        },
        "bumpScale": {
          "value": {}
        },
        "diffuse": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "directionalLights": {
          "properties": {
            "color": {},
            "direction": {},
            "shadow": {},
            "shadowBias": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "directionalShadowMap": {
          "value": {}
        },
        "directionalShadowMatrix": {
          "value": {}
        },
        "displacementBias": {
          "value": {}
        },
        "displacementMap": {
          "value": {}
        },
        "displacementScale": {
          "value": {}
        },
        "emissive": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "emissiveMap": {
          "value": {}
        },
        "envMap": {
          "value": {}
        },
        "envMapIntensity": {
          "value": {}
        },
        "flipEnvMap": {
          "value": {}
        },
        "fogColor": {
          "value": {
            "add": function () {},
            "addColors": function () {},
            "addScalar": function () {},
            "b": {},
            "clone": function () {},
            "convertGammaToLinear": function () {},
            "convertLinearToGamma": function () {},
            "copy": function () {},
            "copyGammaToLinear": function () {},
            "copyLinearToGamma": function () {},
            "equals": function () {},
            "fromArray": function () {},
            "g": {},
            "getHSL": function () {},
            "getHex": function () {},
            "getHexString": function () {},
            "getStyle": function () {},
            "isColor": {},
            "lerp": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "offsetHSL": function () {},
            "r": {},
            "set": function () {},
            "setHSL": function () {},
            "setHex": function () {},
            "setRGB": function () {},
            "setScalar": function () {},
            "setStyle": function () {},
            "sub": function () {},
            "toArray": function () {},
            "toJSON": function () {}
          }
        },
        "fogDensity": {
          "value": {}
        },
        "fogFar": {
          "value": {}
        },
        "fogNear": {
          "value": {}
        },
        "hemisphereLights": {
          "properties": {
            "direction": {},
            "groundColor": {},
            "skyColor": {}
          },
          "value": {}
        },
        "lightMap": {
          "value": {}
        },
        "lightMapIntensity": {
          "value": {}
        },
        "map": {
          "value": {}
        },
        "metalness": {
          "value": {}
        },
        "metalnessMap": {
          "value": {}
        },
        "normalMap": {
          "value": {}
        },
        "normalScale": {
          "value": {
            "add": function () {},
            "addScalar": function () {},
            "addScaledVector": function () {},
            "addVectors": function () {},
            "angle": function () {},
            "applyMatrix3": function () {},
            "ceil": function () {},
            "clamp": function () {},
            "clampLength": function () {},
            "clampScalar": function () {},
            "clone": function () {},
            "copy": function () {},
            "distanceTo": function () {},
            "distanceToManhattan": function () {},
            "distanceToSquared": function () {},
            "divide": function () {},
            "divideScalar": function () {},
            "dot": function () {},
            "equals": function () {},
            "floor": function () {},
            "fromArray": function () {},
            "fromAttribute": function () {},
            "fromBufferAttribute": function () {},
            "getComponent": function () {},
            "isVector2": {},
            "length": function () {},
            "lengthManhattan": function () {},
            "lengthSq": function () {},
            "lerp": function () {},
            "lerpVectors": function () {},
            "manhattanDistanceTo": function () {},
            "manhattanLength": function () {},
            "max": function () {},
            "min": function () {},
            "multiply": function () {},
            "multiplyScalar": function () {},
            "negate": function () {},
            "normalize": function () {},
            "rotateAround": function () {},
            "round": function () {},
            "roundToZero": function () {},
            "set": function () {},
            "setComponent": function () {},
            "setLength": function () {},
            "setScalar": function () {},
            "setX": function () {},
            "setY": function () {},
            "sub": function () {},
            "subScalar": function () {},
            "subVectors": function () {},
            "toArray": function () {},
            "x": {},
            "y": {}
          }
        },
        "opacity": {
          "value": {}
        },
        "pointLights": {
          "properties": {
            "color": {},
            "decay": {},
            "distance": {},
            "position": {},
            "shadow": {},
            "shadowBias": {},
            "shadowCameraFar": {},
            "shadowCameraNear": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "pointShadowMap": {
          "value": {}
        },
        "pointShadowMatrix": {
          "value": {}
        },
        "rectAreaLights": {
          "properties": {
            "color": {},
            "height": {},
            "position": {},
            "width": {}
          },
          "value": {}
        },
        "reflectivity": {
          "value": {}
        },
        "refractionRatio": {
          "value": {}
        },
        "roughness": {
          "value": {}
        },
        "roughnessMap": {
          "value": {}
        },
        "spotLights": {
          "properties": {
            "color": {},
            "coneCos": {},
            "decay": {},
            "direction": {},
            "distance": {},
            "penumbraCos": {},
            "position": {},
            "shadow": {},
            "shadowBias": {},
            "shadowMapSize": {},
            "shadowRadius": {}
          },
          "value": {}
        },
        "spotShadowMap": {
          "value": {}
        },
        "spotShadowMatrix": {
          "value": {}
        },
        "uvTransform": {
          "value": {
            "applyToBuffer": function () {},
            "applyToBufferAttribute": function () {},
            "applyToVector3Array": function () {},
            "clone": function () {},
            "copy": function () {},
            "determinant": function () {},
            "elements": {},
            "equals": function () {},
            "flattenToArrayOffset": function () {},
            "fromArray": function () {},
            "getInverse": function () {},
            "getNormalMatrix": function () {},
            "identity": function () {},
            "isMatrix3": {},
            "multiply": function () {},
            "multiplyMatrices": function () {},
            "multiplyScalar": function () {},
            "multiplyVector3": function () {},
            "multiplyVector3Array": function () {},
            "premultiply": function () {},
            "rotate": function () {},
            "scale": function () {},
            "set": function () {},
            "setFromMatrix4": function () {},
            "setUvTransform": function () {},
            "toArray": function () {},
            "translate": function () {},
            "transpose": function () {},
            "transposeIntoArray": function () {}
          }
        }
      },
      "vertexShader": {}
    }
  },
  "ShaderMaterial": function () {},
  "ShadowMaterial": function () {},
  "Shape": function () {},
  "ShapeBufferGeometry": function () {},
  "ShapeGeometry": function () {},
  "ShapePath": function () {},
  "ShapeUtils": {
    "area": function () {},
    "isClockWise": function () {},
    "triangulateShape": function () {}
  },
  "ShortType": {},
  "Skeleton": function () {},
  "SkeletonHelper": function () {},
  "SkinnedMesh": function () {},
  "SmoothShading": {},
  "Sphere": function () {},
  "SphereBufferGeometry": function () {},
  "SphereGeometry": function () {},
  "Spherical": function () {},
  "SphericalReflectionMapping": {},
  "Spline": function () {},
  "SplineCurve": function () {},
  "SplineCurve3": function () {},
  "SpotLight": function () {},
  "SpotLightHelper": function () {},
  "SpotLightShadow": function () {},
  "Sprite": function () {},
  "SpriteMaterial": function () {},
  "SrcAlphaFactor": {},
  "SrcAlphaSaturateFactor": {},
  "SrcColorFactor": {},
  "StereoCamera": function () {},
  "StringKeyframeTrack": function () {},
  "SubtractEquation": {},
  "SubtractiveBlending": {},
  "TetrahedronBufferGeometry": function () {},
  "TetrahedronGeometry": function () {},
  "TextBufferGeometry": function () {},
  "TextGeometry": function () {},
  "Texture": {
    "DEFAULT_IMAGE": {},
    "DEFAULT_MAPPING": {}
  },
  "TextureLoader": function () {},
  "TorusBufferGeometry": function () {},
  "TorusGeometry": function () {},
  "TorusKnotBufferGeometry": function () {},
  "TorusKnotGeometry": function () {},
  "Triangle": {
    "barycoordFromPoint": function () {},
    "containsPoint": function () {},
    "normal": function () {}
  },
  "TriangleFanDrawMode": {},
  "TriangleStripDrawMode": {},
  "TrianglesDrawMode": {},
  "TubeBufferGeometry": function () {},
  "TubeGeometry": function () {},
  "UVMapping": {},
  "Uint16Attribute": function () {},
  "Uint16BufferAttribute": function () {},
  "Uint32Attribute": function () {},
  "Uint32BufferAttribute": function () {},
  "Uint8Attribute": function () {},
  "Uint8BufferAttribute": function () {},
  "Uint8ClampedAttribute": function () {},
  "Uint8ClampedBufferAttribute": function () {},
  "Uncharted2ToneMapping": {},
  "Uniform": function () {},
  "UniformsLib": {
    "aomap": {
      "aoMap": {
        "value": {}
      },
      "aoMapIntensity": {
        "value": {}
      }
    },
    "bumpmap": {
      "bumpMap": {
        "value": {}
      },
      "bumpScale": {
        "value": {}
      }
    },
    "common": {
      "alphaMap": {
        "value": {}
      },
      "diffuse": {
        "value": {
          "add": function () {},
          "addColors": function () {},
          "addScalar": function () {},
          "b": {},
          "clone": function () {},
          "convertGammaToLinear": function () {},
          "convertLinearToGamma": function () {},
          "copy": function () {},
          "copyGammaToLinear": function () {},
          "copyLinearToGamma": function () {},
          "equals": function () {},
          "fromArray": function () {},
          "g": {},
          "getHSL": function () {},
          "getHex": function () {},
          "getHexString": function () {},
          "getStyle": function () {},
          "isColor": {},
          "lerp": function () {},
          "multiply": function () {},
          "multiplyScalar": function () {},
          "offsetHSL": function () {},
          "r": {},
          "set": function () {},
          "setHSL": function () {},
          "setHex": function () {},
          "setRGB": function () {},
          "setScalar": function () {},
          "setStyle": function () {},
          "sub": function () {},
          "toArray": function () {},
          "toJSON": function () {}
        }
      },
      "map": {
        "value": {}
      },
      "opacity": {
        "value": {}
      },
      "uvTransform": {
        "value": {
          "applyToBuffer": function () {},
          "applyToBufferAttribute": function () {},
          "applyToVector3Array": function () {},
          "clone": function () {},
          "copy": function () {},
          "determinant": function () {},
          "elements": {},
          "equals": function () {},
          "flattenToArrayOffset": function () {},
          "fromArray": function () {},
          "getInverse": function () {},
          "getNormalMatrix": function () {},
          "identity": function () {},
          "isMatrix3": {},
          "multiply": function () {},
          "multiplyMatrices": function () {},
          "multiplyScalar": function () {},
          "multiplyVector3": function () {},
          "multiplyVector3Array": function () {},
          "premultiply": function () {},
          "rotate": function () {},
          "scale": function () {},
          "set": function () {},
          "setFromMatrix4": function () {},
          "setUvTransform": function () {},
          "toArray": function () {},
          "translate": function () {},
          "transpose": function () {},
          "transposeIntoArray": function () {}
        }
      }
    },
    "displacementmap": {
      "displacementBias": {
        "value": {}
      },
      "displacementMap": {
        "value": {}
      },
      "displacementScale": {
        "value": {}
      }
    },
    "emissivemap": {
      "emissiveMap": {
        "value": {}
      }
    },
    "envmap": {
      "envMap": {
        "value": {}
      },
      "flipEnvMap": {
        "value": {}
      },
      "reflectivity": {
        "value": {}
      },
      "refractionRatio": {
        "value": {}
      }
    },
    "fog": {
      "fogColor": {
        "value": {
          "add": function () {},
          "addColors": function () {},
          "addScalar": function () {},
          "b": {},
          "clone": function () {},
          "convertGammaToLinear": function () {},
          "convertLinearToGamma": function () {},
          "copy": function () {},
          "copyGammaToLinear": function () {},
          "copyLinearToGamma": function () {},
          "equals": function () {},
          "fromArray": function () {},
          "g": {},
          "getHSL": function () {},
          "getHex": function () {},
          "getHexString": function () {},
          "getStyle": function () {},
          "isColor": {},
          "lerp": function () {},
          "multiply": function () {},
          "multiplyScalar": function () {},
          "offsetHSL": function () {},
          "r": {},
          "set": function () {},
          "setHSL": function () {},
          "setHex": function () {},
          "setRGB": function () {},
          "setScalar": function () {},
          "setStyle": function () {},
          "sub": function () {},
          "toArray": function () {},
          "toJSON": function () {}
        }
      },
      "fogDensity": {
        "value": {}
      },
      "fogFar": {
        "value": {}
      },
      "fogNear": {
        "value": {}
      }
    },
    "gradientmap": {
      "gradientMap": {
        "value": {}
      }
    },
    "lightmap": {
      "lightMap": {
        "value": {}
      },
      "lightMapIntensity": {
        "value": {}
      }
    },
    "lights": {
      "ambientLightColor": {
        "value": {}
      },
      "directionalLights": {
        "properties": {
          "color": {},
          "direction": {},
          "shadow": {},
          "shadowBias": {},
          "shadowMapSize": {},
          "shadowRadius": {}
        },
        "value": {}
      },
      "directionalShadowMap": {
        "value": {}
      },
      "directionalShadowMatrix": {
        "value": {}
      },
      "hemisphereLights": {
        "properties": {
          "direction": {},
          "groundColor": {},
          "skyColor": {}
        },
        "value": {}
      },
      "pointLights": {
        "properties": {
          "color": {},
          "decay": {},
          "distance": {},
          "position": {},
          "shadow": {},
          "shadowBias": {},
          "shadowCameraFar": {},
          "shadowCameraNear": {},
          "shadowMapSize": {},
          "shadowRadius": {}
        },
        "value": {}
      },
      "pointShadowMap": {
        "value": {}
      },
      "pointShadowMatrix": {
        "value": {}
      },
      "rectAreaLights": {
        "properties": {
          "color": {},
          "height": {},
          "position": {},
          "width": {}
        },
        "value": {}
      },
      "spotLights": {
        "properties": {
          "color": {},
          "coneCos": {},
          "decay": {},
          "direction": {},
          "distance": {},
          "penumbraCos": {},
          "position": {},
          "shadow": {},
          "shadowBias": {},
          "shadowMapSize": {},
          "shadowRadius": {}
        },
        "value": {}
      },
      "spotShadowMap": {
        "value": {}
      },
      "spotShadowMatrix": {
        "value": {}
      }
    },
    "metalnessmap": {
      "metalnessMap": {
        "value": {}
      }
    },
    "normalmap": {
      "normalMap": {
        "value": {}
      },
      "normalScale": {
        "value": {
          "add": function () {},
          "addScalar": function () {},
          "addScaledVector": function () {},
          "addVectors": function () {},
          "angle": function () {},
          "applyMatrix3": function () {},
          "ceil": function () {},
          "clamp": function () {},
          "clampLength": function () {},
          "clampScalar": function () {},
          "clone": function () {},
          "copy": function () {},
          "distanceTo": function () {},
          "distanceToManhattan": function () {},
          "distanceToSquared": function () {},
          "divide": function () {},
          "divideScalar": function () {},
          "dot": function () {},
          "equals": function () {},
          "floor": function () {},
          "fromArray": function () {},
          "fromAttribute": function () {},
          "fromBufferAttribute": function () {},
          "getComponent": function () {},
          "isVector2": {},
          "length": function () {},
          "lengthManhattan": function () {},
          "lengthSq": function () {},
          "lerp": function () {},
          "lerpVectors": function () {},
          "manhattanDistanceTo": function () {},
          "manhattanLength": function () {},
          "max": function () {},
          "min": function () {},
          "multiply": function () {},
          "multiplyScalar": function () {},
          "negate": function () {},
          "normalize": function () {},
          "rotateAround": function () {},
          "round": function () {},
          "roundToZero": function () {},
          "set": function () {},
          "setComponent": function () {},
          "setLength": function () {},
          "setScalar": function () {},
          "setX": function () {},
          "setY": function () {},
          "sub": function () {},
          "subScalar": function () {},
          "subVectors": function () {},
          "toArray": function () {},
          "x": {},
          "y": {}
        }
      }
    },
    "points": {
      "diffuse": {
        "value": {
          "add": function () {},
          "addColors": function () {},
          "addScalar": function () {},
          "b": {},
          "clone": function () {},
          "convertGammaToLinear": function () {},
          "convertLinearToGamma": function () {},
          "copy": function () {},
          "copyGammaToLinear": function () {},
          "copyLinearToGamma": function () {},
          "equals": function () {},
          "fromArray": function () {},
          "g": {},
          "getHSL": function () {},
          "getHex": function () {},
          "getHexString": function () {},
          "getStyle": function () {},
          "isColor": {},
          "lerp": function () {},
          "multiply": function () {},
          "multiplyScalar": function () {},
          "offsetHSL": function () {},
          "r": {},
          "set": function () {},
          "setHSL": function () {},
          "setHex": function () {},
          "setRGB": function () {},
          "setScalar": function () {},
          "setStyle": function () {},
          "sub": function () {},
          "toArray": function () {},
          "toJSON": function () {}
        }
      },
      "map": {
        "value": {}
      },
      "opacity": {
        "value": {}
      },
      "scale": {
        "value": {}
      },
      "size": {
        "value": {}
      },
      "uvTransform": {
        "value": {
          "applyToBuffer": function () {},
          "applyToBufferAttribute": function () {},
          "applyToVector3Array": function () {},
          "clone": function () {},
          "copy": function () {},
          "determinant": function () {},
          "elements": {},
          "equals": function () {},
          "flattenToArrayOffset": function () {},
          "fromArray": function () {},
          "getInverse": function () {},
          "getNormalMatrix": function () {},
          "identity": function () {},
          "isMatrix3": {},
          "multiply": function () {},
          "multiplyMatrices": function () {},
          "multiplyScalar": function () {},
          "multiplyVector3": function () {},
          "multiplyVector3Array": function () {},
          "premultiply": function () {},
          "rotate": function () {},
          "scale": function () {},
          "set": function () {},
          "setFromMatrix4": function () {},
          "setUvTransform": function () {},
          "toArray": function () {},
          "translate": function () {},
          "transpose": function () {},
          "transposeIntoArray": function () {}
        }
      }
    },
    "roughnessmap": {
      "roughnessMap": {
        "value": {}
      }
    },
    "specularmap": {
      "specularMap": {
        "value": {}
      }
    }
  },
  "UniformsUtils": {
    "clone": function () {},
    "merge": function () {}
  },
  "UnsignedByteType": {},
  "UnsignedInt248Type": {},
  "UnsignedIntType": {},
  "UnsignedShort4444Type": {},
  "UnsignedShort5551Type": {},
  "UnsignedShort565Type": {},
  "UnsignedShortType": {},
  "Vector2": function () {},
  "Vector3": function () {},
  "Vector4": function () {},
  "VectorKeyframeTrack": function () {},
  "Vertex": function () {},
  "VertexColors": {},
  "VertexNormalsHelper": function () {},
  "VideoTexture": function () {},
  "WebGLRenderTarget": function () {},
  "WebGLRenderTargetCube": function () {},
  "WebGLRenderer": function () {},
  "WebGLUtils": function () {},
  "WireframeGeometry": function () {},
  "WireframeHelper": function () {},
  "WrapAroundEnding": {},
  "XHRLoader": function () {},
  "ZeroCurvatureEnding": {},
  "ZeroFactor": {},
  "ZeroSlopeEnding": {},
  "sRGBEncoding": {}
};
THREE.AmbientLight.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isAmbientLight": function () {},
  "isLight": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.AnimationClip.prototype = {
  "optimize": function () {},
  "resetDuration": function () {},
  "trim": function () {}
};
THREE.AnimationMixer.prototype = {
  "_activateAction": function () {},
  "_addInactiveAction": function () {},
  "_addInactiveBinding": function () {},
  "_bindAction": function () {},
  "_controlInterpolantsResultBuffer": function () {},
  "_deactivateAction": function () {},
  "_initMemoryManager": function () {},
  "_isActiveAction": function () {},
  "_lendAction": function () {},
  "_lendBinding": function () {},
  "_lendControlInterpolant": function () {},
  "_removeInactiveAction": function () {},
  "_removeInactiveBinding": function () {},
  "_removeInactiveBindingsForAction": function () {},
  "_takeBackAction": function () {},
  "_takeBackBinding": function () {},
  "_takeBackControlInterpolant": function () {},
  "addEventListener": function () {},
  "clipAction": function () {},
  "constructor": function () {},
  "dispatchEvent": function () {},
  "existingAction": function () {},
  "getRoot": function () {},
  "hasEventListener": function () {},
  "removeEventListener": function () {},
  "stopAllAction": function () {},
  "uncacheAction": function () {},
  "uncacheClip": function () {},
  "uncacheRoot": function () {},
  "update": function () {}
};
THREE.AnimationObjectGroup.prototype = {
  "add": function () {},
  "isAnimationObjectGroup": function () {},
  "remove": function () {},
  "subscribe_": function () {},
  "uncache": function () {},
  "unsubscribe_": function () {}
};
THREE.ArcCurve.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isArcCurve": function () {},
  "isEllipseCurve": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.ArrayCamera.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clearViewOffset": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getEffectiveFOV": function () {},
  "getFilmHeight": function () {},
  "getFilmWidth": function () {},
  "getFocalLength": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isArrayCamera": function () {},
  "isCamera": function () {},
  "isObject3D": function () {},
  "isPerspectiveCamera": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setFocalLength": function () {},
  "setLens": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "setViewOffset": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "updateProjectionMatrix": function () {},
  "worldToLocal": function () {}
};
THREE.ArrowHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setColor": function () {},
  "setDirection": function () {},
  "setLength": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.Audio.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "connect": function () {},
  "constructor": function () {},
  "copy": function () {},
  "disconnect": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getFilter": function () {},
  "getFilters": function () {},
  "getLoop": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getOutput": function () {},
  "getPlaybackRate": function () {},
  "getVolume": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "load": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "onEnded": function () {},
  "pause": function () {},
  "play": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setBuffer": function () {},
  "setFilter": function () {},
  "setFilters": function () {},
  "setLoop": function () {},
  "setNodeSource": function () {},
  "setPlaybackRate": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "setVolume": function () {},
  "stop": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.AudioAnalyser.prototype = {
  "getAverageFrequency": function () {},
  "getData": function () {},
  "getFrequencyData": function () {}
};
THREE.AudioListener.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getFilter": function () {},
  "getInput": function () {},
  "getMasterVolume": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "removeFilter": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setFilter": function () {},
  "setMasterVolume": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.AudioLoader.prototype = {
  "load": function () {}
};
THREE.AxesHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineSegments": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.Bone.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isBone": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.BooleanKeyframeTrack.prototype = {
  "DefaultInterpolation": function () {},
  "InterpolantFactoryMethodDiscrete": function () {},
  "InterpolantFactoryMethodLinear": function () {},
  "InterpolantFactoryMethodSmooth": function () {},
  "TimeBufferType": function () {},
  "ValueBufferType": function () {},
  "ValueTypeName": function () {},
  "constructor": function () {},
  "getInterpolation": function () {},
  "getValueSize": function () {},
  "optimize": function () {},
  "scale": function () {},
  "setInterpolation": function () {},
  "shift": function () {},
  "trim": function () {},
  "validate": function () {}
};
THREE.Box2.prototype = {
  "center": function () {},
  "clampPoint": function () {},
  "clone": function () {},
  "containsBox": function () {},
  "containsPoint": function () {},
  "copy": function () {},
  "distanceToPoint": function () {},
  "empty": function () {},
  "equals": function () {},
  "expandByPoint": function () {},
  "expandByScalar": function () {},
  "expandByVector": function () {},
  "getCenter": function () {},
  "getParameter": function () {},
  "getSize": function () {},
  "intersect": function () {},
  "intersectsBox": function () {},
  "isEmpty": function () {},
  "isIntersectionBox": function () {},
  "makeEmpty": function () {},
  "set": function () {},
  "setFromCenterAndSize": function () {},
  "setFromPoints": function () {},
  "size": function () {},
  "translate": function () {},
  "union": function () {}
};
THREE.Box3.prototype = {
  "applyMatrix4": function () {},
  "center": function () {},
  "clampPoint": function () {},
  "clone": function () {},
  "containsBox": function () {},
  "containsPoint": function () {},
  "copy": function () {},
  "distanceToPoint": function () {},
  "empty": function () {},
  "equals": function () {},
  "expandByObject": function () {},
  "expandByPoint": function () {},
  "expandByScalar": function () {},
  "expandByVector": function () {},
  "getBoundingSphere": function () {},
  "getCenter": function () {},
  "getParameter": function () {},
  "getSize": function () {},
  "intersect": function () {},
  "intersectsBox": function () {},
  "intersectsPlane": function () {},
  "intersectsSphere": function () {},
  "isBox3": function () {},
  "isEmpty": function () {},
  "isIntersectionBox": function () {},
  "isIntersectionSphere": function () {},
  "makeEmpty": function () {},
  "set": function () {},
  "setFromArray": function () {},
  "setFromBufferAttribute": function () {},
  "setFromCenterAndSize": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "size": function () {},
  "translate": function () {},
  "union": function () {}
};
THREE.Box3Helper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineSegments": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.BoxBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.BoxGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.BoxHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineSegments": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setFromObject": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.BufferAttribute.prototype = {
  "clone": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.BufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.BufferGeometryLoader.prototype = {
  "load": function () {},
  "parse": function () {}
};
THREE.Camera.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isCamera": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.CameraHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineSegments": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.CanvasTexture.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isTexture": function () {},
  "removeEventListener": function () {},
  "toJSON": function () {},
  "transformUv": function () {}
};
THREE.CatmullRomCurve3.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isCatmullRomCurve3": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.CircleBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.CircleGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.Clock.prototype = {
  "getDelta": function () {},
  "getElapsedTime": function () {},
  "start": function () {},
  "stop": function () {}
};
THREE.ClosedSplineCurve3.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isCatmullRomCurve3": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.Color.prototype = {
  "add": function () {},
  "addColors": function () {},
  "addScalar": function () {},
  "b": function () {},
  "clone": function () {},
  "convertGammaToLinear": function () {},
  "convertLinearToGamma": function () {},
  "copy": function () {},
  "copyGammaToLinear": function () {},
  "copyLinearToGamma": function () {},
  "equals": function () {},
  "fromArray": function () {},
  "g": function () {},
  "getHSL": function () {},
  "getHex": function () {},
  "getHexString": function () {},
  "getStyle": function () {},
  "isColor": function () {},
  "lerp": function () {},
  "multiply": function () {},
  "multiplyScalar": function () {},
  "offsetHSL": function () {},
  "r": function () {},
  "set": function () {},
  "setHSL": function () {},
  "setHex": function () {},
  "setRGB": function () {},
  "setScalar": function () {},
  "setStyle": function () {},
  "sub": function () {},
  "toArray": function () {},
  "toJSON": function () {}
};
THREE.ColorKeyframeTrack.prototype = {
  "DefaultInterpolation": function () {},
  "InterpolantFactoryMethodDiscrete": function () {},
  "InterpolantFactoryMethodLinear": function () {},
  "InterpolantFactoryMethodSmooth": function () {},
  "TimeBufferType": function () {},
  "ValueBufferType": function () {},
  "ValueTypeName": function () {},
  "constructor": function () {},
  "getInterpolation": function () {},
  "getValueSize": function () {},
  "optimize": function () {},
  "scale": function () {},
  "setInterpolation": function () {},
  "shift": function () {},
  "trim": function () {},
  "validate": function () {}
};
THREE.CompressedTexture.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isCompressedTexture": function () {},
  "isTexture": function () {},
  "removeEventListener": function () {},
  "toJSON": function () {},
  "transformUv": function () {}
};
THREE.CompressedTextureLoader.prototype = {
  "load": function () {},
  "setPath": function () {}
};
THREE.ConeBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.ConeGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.CubeCamera.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateCubeMap": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.CubeGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.CubeTexture.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isCubeTexture": function () {},
  "isTexture": function () {},
  "removeEventListener": function () {},
  "toJSON": function () {},
  "transformUv": function () {}
};
THREE.CubeTextureLoader.prototype = {
  "crossOrigin": function () {},
  "load": function () {},
  "setCrossOrigin": function () {},
  "setPath": function () {}
};
THREE.CubicBezierCurve.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isCubicBezierCurve": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.CubicBezierCurve3.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isCubicBezierCurve3": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.CubicInterpolant.prototype = {
  "DefaultSettings_": function () {},
  "afterEnd_": function () {},
  "beforeStart_": function () {},
  "constructor": function () {},
  "copySampleValue_": function () {},
  "evaluate": function () {},
  "getSettings_": function () {},
  "interpolate_": function () {},
  "intervalChanged_": function () {},
  "settings": function () {}
};
THREE.Curve.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.CurvePath.prototype = {
  "add": function () {},
  "clone": function () {},
  "closePath": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "createGeometry": function () {},
  "createPointsGeometry": function () {},
  "createSpacedPointsGeometry": function () {},
  "fromJSON": function () {},
  "getCurveLengths": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.CylinderBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.CylinderGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.Cylindrical.prototype = {
  "clone": function () {},
  "copy": function () {},
  "set": function () {},
  "setFromVector3": function () {}
};
THREE.DataTexture.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isDataTexture": function () {},
  "isTexture": function () {},
  "removeEventListener": function () {},
  "toJSON": function () {},
  "transformUv": function () {}
};
THREE.DataTextureLoader.prototype = {
  "load": function () {}
};
THREE.DepthTexture.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isDepthTexture": function () {},
  "isTexture": function () {},
  "removeEventListener": function () {},
  "toJSON": function () {},
  "transformUv": function () {}
};
THREE.DirectionalLight.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isDirectionalLight": function () {},
  "isLight": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.DirectionalLightHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.DirectionalLightShadow.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "toJSON": function () {}
};
THREE.DiscreteInterpolant.prototype = {
  "DefaultSettings_": function () {},
  "afterEnd_": function () {},
  "beforeStart_": function () {},
  "constructor": function () {},
  "copySampleValue_": function () {},
  "evaluate": function () {},
  "getSettings_": function () {},
  "interpolate_": function () {},
  "intervalChanged_": function () {},
  "settings": function () {}
};
THREE.DodecahedronBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.DodecahedronGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.EdgesGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.EllipseCurve.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isEllipseCurve": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.Euler.prototype = {
  "clone": function () {},
  "copy": function () {},
  "equals": function () {},
  "fromArray": function () {},
  "isEuler": function () {},
  "onChange": function () {},
  "onChangeCallback": function () {},
  "reorder": function () {},
  "set": function () {},
  "setFromQuaternion": function () {},
  "setFromRotationMatrix": function () {},
  "setFromVector3": function () {},
  "toArray": function () {},
  "toVector3": function () {}
};
THREE.EventDispatcher.prototype = {
  "addEventListener": function () {},
  "dispatchEvent": function () {},
  "hasEventListener": function () {},
  "removeEventListener": function () {}
};
THREE.ExtrudeBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "addShape": function () {},
  "addShapeList": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getArrays": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.ExtrudeGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.Face3.prototype = {
  "clone": function () {},
  "copy": function () {}
};
THREE.FaceNormalsHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineSegments": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.FileLoader.prototype = {
  "load": function () {},
  "setMimeType": function () {},
  "setPath": function () {},
  "setRequestHeader": function () {},
  "setResponseType": function () {},
  "setWithCredentials": function () {}
};
THREE.Float32BufferAttribute.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.Float64BufferAttribute.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.Fog.prototype = {
  "clone": function () {},
  "isFog": function () {},
  "toJSON": function () {}
};
THREE.FogExp2.prototype = {
  "clone": function () {},
  "isFogExp2": function () {},
  "toJSON": function () {}
};
THREE.Font.prototype = {
  "generateShapes": function () {},
  "isFont": function () {}
};
THREE.FontLoader.prototype = {
  "load": function () {},
  "parse": function () {},
  "setPath": function () {}
};
THREE.Frustum.prototype = {
  "clone": function () {},
  "containsPoint": function () {},
  "copy": function () {},
  "intersectsBox": function () {},
  "intersectsObject": function () {},
  "intersectsSphere": function () {},
  "intersectsSprite": function () {},
  "set": function () {},
  "setFromMatrix": function () {}
};
THREE.Geometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "vertices": function() {}
};
THREE.GridHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineSegments": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setColors": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.Group.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isGroup": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.HemisphereLight.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isHemisphereLight": function () {},
  "isLight": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.HemisphereLightHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.IcosahedronBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.IcosahedronGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.ImageBitmapLoader.prototype = {
  "constructor": function () {},
  "load": function () {},
  "setCrossOrigin": function () {},
  "setOptions": function () {},
  "setPath": function () {}
};
THREE.ImageLoader.prototype = {
  "crossOrigin": function () {},
  "load": function () {},
  "setCrossOrigin": function () {},
  "setPath": function () {}
};
THREE.ImmediateRenderObject.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isImmediateRenderObject": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.InstancedBufferAttribute.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "isInstancedBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.InstancedBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "isInstancedBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.InstancedInterleavedBuffer.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyAt": function () {},
  "isInstancedInterleavedBuffer": function () {},
  "isInterleavedBuffer": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {}
};
THREE.Int16BufferAttribute.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.Int32BufferAttribute.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.Int8BufferAttribute.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.InterleavedBuffer.prototype = {
  "clone": function () {},
  "copy": function () {},
  "copyAt": function () {},
  "isInterleavedBuffer": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {}
};
THREE.InterleavedBufferAttribute.prototype = {
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isInterleavedBufferAttribute": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.Interpolant.prototype = {
  "DefaultSettings_": function () {},
  "afterEnd_": function () {},
  "beforeStart_": function () {},
  "copySampleValue_": function () {},
  "evaluate": function () {},
  "getSettings_": function () {},
  "interpolate_": function () {},
  "intervalChanged_": function () {},
  "settings": function () {}
};
THREE.JSONLoader.prototype = {
  "load": function () {},
  "parse": function () {},
  "setTexturePath": function () {}
};
THREE.KeyframeTrack.prototype = {
  "DefaultInterpolation": function () {},
  "InterpolantFactoryMethodDiscrete": function () {},
  "InterpolantFactoryMethodLinear": function () {},
  "InterpolantFactoryMethodSmooth": function () {},
  "TimeBufferType": function () {},
  "ValueBufferType": function () {},
  "getInterpolation": function () {},
  "getValueSize": function () {},
  "optimize": function () {},
  "scale": function () {},
  "setInterpolation": function () {},
  "shift": function () {},
  "trim": function () {},
  "validate": function () {}
};
THREE.LOD.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "addLevel": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getObjectForDistance": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.LatheBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.LatheGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.Layers.prototype = {
  "disable": function () {},
  "enable": function () {},
  "set": function () {},
  "test": function () {},
  "toggle": function () {}
};
THREE.LensFlare.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLensFlare": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateLensFlares": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.Light.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLight": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.LightShadow.prototype = {
  "clone": function () {},
  "copy": function () {},
  "toJSON": function () {}
};
THREE.Line.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {},
  "transparent": function () {},
  "opacity": function () {}
};
THREE.Line3.prototype = {
  "applyMatrix4": function () {},
  "at": function () {},
  "center": function () {},
  "clone": function () {},
  "closestPointToPoint": function () {},
  "closestPointToPointParameter": function () {},
  "copy": function () {},
  "delta": function () {},
  "distance": function () {},
  "distanceSq": function () {},
  "equals": function () {},
  "getCenter": function () {},
  "set": function () {},
  "transparent": function () {},
  "opacity": function () {}
};
THREE.LineBasicMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isLineBasicMaterial": function () {},
  "isMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {},
  "transparent": function () {},
  "opacity": function () {}
};
THREE.LineCurve.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isLineCurve": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.LineCurve3.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isLineCurve3": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.LineDashedMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isLineBasicMaterial": function () {},
  "isLineDashedMaterial": function () {},
  "isMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.LineLoop.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineLoop": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {},
  "visible": function () {}
};
THREE.LineSegments.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineSegments": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.LinearInterpolant.prototype = {
  "DefaultSettings_": function () {},
  "afterEnd_": function () {},
  "beforeStart_": function () {},
  "constructor": function () {},
  "copySampleValue_": function () {},
  "evaluate": function () {},
  "getSettings_": function () {},
  "interpolate_": function () {},
  "intervalChanged_": function () {},
  "settings": function () {}
};
THREE.Loader.prototype = {
  "createMaterial": function () {},
  "crossOrigin": function () {},
  "extractUrlBase": function () {},
  "initMaterials": function () {}
};
THREE.Material.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.MaterialLoader.prototype = {
  "load": function () {},
  "parse": function () {},
  "setTextures": function () {}
};
THREE.Matrix3.prototype = {
  "applyToBuffer": function () {},
  "applyToBufferAttribute": function () {},
  "applyToVector3Array": function () {},
  "clone": function () {},
  "copy": function () {},
  "determinant": function () {},
  "equals": function () {},
  "flattenToArrayOffset": function () {},
  "fromArray": function () {},
  "getInverse": function () {},
  "getNormalMatrix": function () {},
  "identity": function () {},
  "isMatrix3": function () {},
  "multiply": function () {},
  "multiplyMatrices": function () {},
  "multiplyScalar": function () {},
  "multiplyVector3": function () {},
  "multiplyVector3Array": function () {},
  "premultiply": function () {},
  "rotate": function () {},
  "scale": function () {},
  "set": function () {},
  "setFromMatrix4": function () {},
  "setUvTransform": function () {},
  "toArray": function () {},
  "translate": function () {},
  "transpose": function () {},
  "transposeIntoArray": function () {}
};
THREE.Matrix4.prototype = {
  "applyToBuffer": function () {},
  "applyToBufferAttribute": function () {},
  "applyToVector3Array": function () {},
  "clone": function () {},
  "compose": function () {},
  "copy": function () {},
  "copyPosition": function () {},
  "crossVector": function () {},
  "decompose": function () {},
  "determinant": function () {},
  "equals": function () {},
  "extractBasis": function () {},
  "extractPosition": function () {},
  "extractRotation": function () {},
  "flattenToArrayOffset": function () {},
  "fromArray": function () {},
  "getInverse": function () {},
  "getMaxScaleOnAxis": function () {},
  "getPosition": function () {},
  "identity": function () {},
  "isMatrix4": function () {},
  "lookAt": function () {},
  "makeBasis": function () {},
  "makeFrustum": function () {},
  "makeOrthographic": function () {},
  "makePerspective": function () {},
  "makeRotationAxis": function () {},
  "makeRotationFromEuler": function () {},
  "makeRotationFromQuaternion": function () {},
  "makeRotationX": function () {},
  "makeRotationY": function () {},
  "makeRotationZ": function () {},
  "makeScale": function () {},
  "makeShear": function () {},
  "makeTranslation": function () {},
  "multiply": function () {},
  "multiplyMatrices": function () {},
  "multiplyScalar": function () {},
  "multiplyToArray": function () {},
  "multiplyVector3": function () {},
  "multiplyVector3Array": function () {},
  "multiplyVector4": function () {},
  "premultiply": function () {},
  "rotateAxis": function () {},
  "rotateByAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "set": function () {},
  "setPosition": function () {},
  "setRotationFromQuaternion": function () {},
  "toArray": function () {},
  "translate": function () {},
  "transpose": function () {}
};
THREE.Mesh.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isMesh": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setDrawMode": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "updateMorphTargets": function () {},
  "worldToLocal": function () {}
};
THREE.MeshBasicMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isMeshBasicMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.MeshDepthMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isMeshDepthMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.MeshDistanceMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isMeshDistanceMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.MeshLambertMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isMeshLambertMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.MeshNormalMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isMeshNormalMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.MeshPhongMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isMeshPhongMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.MeshPhysicalMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isMeshPhysicalMaterial": function () {},
  "isMeshStandardMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.MeshStandardMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isMeshStandardMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.MeshToonMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isMeshPhongMaterial": function () {},
  "isMeshToonMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.NumberKeyframeTrack.prototype = {
  "DefaultInterpolation": function () {},
  "InterpolantFactoryMethodDiscrete": function () {},
  "InterpolantFactoryMethodLinear": function () {},
  "InterpolantFactoryMethodSmooth": function () {},
  "TimeBufferType": function () {},
  "ValueBufferType": function () {},
  "ValueTypeName": function () {},
  "constructor": function () {},
  "getInterpolation": function () {},
  "getValueSize": function () {},
  "optimize": function () {},
  "scale": function () {},
  "setInterpolation": function () {},
  "shift": function () {},
  "trim": function () {},
  "validate": function () {}
};
THREE.Object3D.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.ObjectLoader.prototype = {
  "load": function () {},
  "parse": function () {},
  "parseAnimations": function () {},
  "parseGeometries": function () {},
  "parseImages": function () {},
  "parseMaterials": function () {},
  "parseObject": function () {},
  "parseShape": function () {},
  "parseTextures": function () {},
  "setCrossOrigin": function () {},
  "setTexturePath": function () {}
};
THREE.OctahedronBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.OctahedronGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.OrthographicCamera.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clearViewOffset": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isCamera": function () {},
  "isObject3D": function () {},
  "isOrthographicCamera": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "setViewOffset": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "updateProjectionMatrix": function () {},
  "worldToLocal": function () {},
  "top": function () {},
  "right": function () {},
  "bottom": function () {},
  "left": function () {}
};
THREE.ParametricBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.ParametricGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.Path.prototype = {
  "absarc": function () {},
  "absellipse": function () {},
  "add": function () {},
  "arc": function () {},
  "bezierCurveTo": function () {},
  "clone": function () {},
  "closePath": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "createGeometry": function () {},
  "createPointsGeometry": function () {},
  "createSpacedPointsGeometry": function () {},
  "ellipse": function () {},
  "fromJSON": function () {},
  "fromPoints": function () {},
  "getCurveLengths": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "lineTo": function () {},
  "moveTo": function () {},
  "quadraticCurveTo": function () {},
  "setFromPoints": function () {},
  "splineThru": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.PerspectiveCamera.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clearViewOffset": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getEffectiveFOV": function () {},
  "getFilmHeight": function () {},
  "getFilmWidth": function () {},
  "getFocalLength": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isCamera": function () {},
  "isObject3D": function () {},
  "isPerspectiveCamera": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setFocalLength": function () {},
  "setLens": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "setViewOffset": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "updateProjectionMatrix": function () {},
  "worldToLocal": function () {}
};
THREE.Plane.prototype = {
  "applyMatrix4": function () {},
  "clone": function () {},
  "coplanarPoint": function () {},
  "copy": function () {},
  "distanceToPoint": function () {},
  "distanceToSphere": function () {},
  "equals": function () {},
  "intersectLine": function () {},
  "intersectsBox": function () {},
  "intersectsLine": function () {},
  "intersectsSphere": function () {},
  "isIntersectionLine": function () {},
  "negate": function () {},
  "normalize": function () {},
  "projectPoint": function () {},
  "set": function () {},
  "setComponents": function () {},
  "setFromCoplanarPoints": function () {},
  "setFromNormalAndCoplanarPoint": function () {},
  "translate": function () {}
};
THREE.PlaneBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.PlaneGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.PlaneHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.PointLight.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLight": function () {},
  "isObject3D": function () {},
  "isPointLight": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.PointLightHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isMesh": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setDrawMode": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "updateMorphTargets": function () {},
  "worldToLocal": function () {}
};
THREE.Points.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "isPoints": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.PointsMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isPointsMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.PolarGridHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineSegments": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.PolyhedronBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.PolyhedronGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.PositionalAudio.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "connect": function () {},
  "constructor": function () {},
  "copy": function () {},
  "disconnect": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getDistanceModel": function () {},
  "getFilter": function () {},
  "getFilters": function () {},
  "getLoop": function () {},
  "getMaxDistance": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getOutput": function () {},
  "getPlaybackRate": function () {},
  "getRefDistance": function () {},
  "getRolloffFactor": function () {},
  "getVolume": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "load": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "onEnded": function () {},
  "pause": function () {},
  "play": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setBuffer": function () {},
  "setDistanceModel": function () {},
  "setFilter": function () {},
  "setFilters": function () {},
  "setLoop": function () {},
  "setMaxDistance": function () {},
  "setNodeSource": function () {},
  "setPlaybackRate": function () {},
  "setRefDistance": function () {},
  "setRolloffFactor": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "setVolume": function () {},
  "stop": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.PropertyBinding.prototype = {
  "BindingType": function () {},
  "GetterByBindingType": function () {},
  "SetterByBindingTypeAndVersioning": function () {},
  "Versioning": function () {},
  "_getValue_unavailable": function () {},
  "_getValue_unbound": function () {},
  "_setValue_unavailable": function () {},
  "_setValue_unbound": function () {},
  "bind": function () {},
  "getValue": function () {},
  "setValue": function () {},
  "unbind": function () {}
};
THREE.PropertyBinding.Composite.prototype = {
  "bind": function () {},
  "getValue": function () {},
  "setValue": function () {},
  "unbind": function () {}
};
THREE.PropertyMixer.prototype = {
  "_lerp": function () {},
  "_select": function () {},
  "_slerp": function () {},
  "accumulate": function () {},
  "apply": function () {},
  "restoreOriginalState": function () {},
  "saveOriginalState": function () {}
};
THREE.QuadraticBezierCurve.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isQuadraticBezierCurve": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.QuadraticBezierCurve3.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isQuadraticBezierCurve3": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.Quaternion.prototype = {
  "clone": function () {},
  "conjugate": function () {},
  "copy": function () {},
  "dot": function () {},
  "equals": function () {},
  "fromArray": function () {},
  "inverse": function () {},
  "length": function () {},
  "lengthSq": function () {},
  "multiply": function () {},
  "multiplyQuaternions": function () {},
  "multiplyVector3": function () {},
  "normalize": function () {},
  "onChange": function () {},
  "onChangeCallback": function () {},
  "premultiply": function () {},
  "set": function () {},
  "setFromAxisAngle": function () {},
  "setFromEuler": function () {},
  "setFromRotationMatrix": function () {},
  "setFromUnitVectors": function () {},
  "slerp": function () {},
  "toArray": function () {}
};
THREE.QuaternionKeyframeTrack.prototype = {
  "DefaultInterpolation": function () {},
  "InterpolantFactoryMethodDiscrete": function () {},
  "InterpolantFactoryMethodLinear": function () {},
  "InterpolantFactoryMethodSmooth": function () {},
  "TimeBufferType": function () {},
  "ValueBufferType": function () {},
  "ValueTypeName": function () {},
  "constructor": function () {},
  "getInterpolation": function () {},
  "getValueSize": function () {},
  "optimize": function () {},
  "scale": function () {},
  "setInterpolation": function () {},
  "shift": function () {},
  "trim": function () {},
  "validate": function () {}
};
THREE.QuaternionLinearInterpolant.prototype = {
  "DefaultSettings_": function () {},
  "afterEnd_": function () {},
  "beforeStart_": function () {},
  "constructor": function () {},
  "copySampleValue_": function () {},
  "evaluate": function () {},
  "getSettings_": function () {},
  "interpolate_": function () {},
  "intervalChanged_": function () {},
  "settings": function () {}
};
THREE.RawShaderMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isRawShaderMaterial": function () {},
  "isShaderMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.Ray.prototype = {
  "applyMatrix4": function () {},
  "at": function () {},
  "clone": function () {},
  "closestPointToPoint": function () {},
  "copy": function () {},
  "distanceSqToPoint": function () {},
  "distanceSqToSegment": function () {},
  "distanceToPlane": function () {},
  "distanceToPoint": function () {},
  "equals": function () {},
  "intersectBox": function () {},
  "intersectPlane": function () {},
  "intersectSphere": function () {},
  "intersectTriangle": function () {},
  "intersectsBox": function () {},
  "intersectsPlane": function () {},
  "intersectsSphere": function () {},
  "isIntersectionBox": function () {},
  "isIntersectionPlane": function () {},
  "isIntersectionSphere": function () {},
  "lookAt": function () {},
  "recast": function () {},
  "set": function () {}
};
THREE.Raycaster.prototype = {
  "intersectObject": function () {},
  "intersectObjects": function () {},
  "linePrecision": function () {},
  "set": function () {},
  "setFromCamera": function () {}
};
THREE.RectAreaLight.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLight": function () {},
  "isObject3D": function () {},
  "isRectAreaLight": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.RectAreaLightHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.RingBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.RingGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.Scene.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.ShaderMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isShaderMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.ShadowMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isShadowMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.Shape.prototype = {
  "absarc": function () {},
  "absellipse": function () {},
  "add": function () {},
  "arc": function () {},
  "bezierCurveTo": function () {},
  "clone": function () {},
  "closePath": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "createGeometry": function () {},
  "createPointsGeometry": function () {},
  "createSpacedPointsGeometry": function () {},
  "ellipse": function () {},
  "extractAllPoints": function () {},
  "extractPoints": function () {},
  "extrude": function () {},
  "fromJSON": function () {},
  "fromPoints": function () {},
  "getCurveLengths": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getPointsHoles": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "lineTo": function () {},
  "makeGeometry": function () {},
  "moveTo": function () {},
  "quadraticCurveTo": function () {},
  "setFromPoints": function () {},
  "splineThru": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.ShapeBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.ShapeGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.ShapePath.prototype = {
  "bezierCurveTo": function () {},
  "lineTo": function () {},
  "moveTo": function () {},
  "quadraticCurveTo": function () {},
  "splineThru": function () {},
  "toShapes": function () {}
};
THREE.Skeleton.prototype = {
  "calculateInverses": function () {},
  "clone": function () {},
  "pose": function () {},
  "update": function () {}
};
THREE.SkeletonHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineSegments": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.SkinnedMesh.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "bind": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "initBones": function () {},
  "isMesh": function () {},
  "isObject3D": function () {},
  "isSkinnedMesh": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "normalizeSkinWeights": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "pose": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setDrawMode": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "updateMorphTargets": function () {},
  "worldToLocal": function () {}
};
THREE.Sphere.prototype = {
  "applyMatrix4": function () {},
  "clampPoint": function () {},
  "clone": function () {},
  "containsPoint": function () {},
  "copy": function () {},
  "distanceToPoint": function () {},
  "empty": function () {},
  "equals": function () {},
  "getBoundingBox": function () {},
  "intersectsBox": function () {},
  "intersectsPlane": function () {},
  "intersectsSphere": function () {},
  "set": function () {},
  "setFromPoints": function () {},
  "translate": function () {}
};
THREE.SphereBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.SphereGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.Spherical.prototype = {
  "clone": function () {},
  "copy": function () {},
  "makeSafe": function () {},
  "set": function () {},
  "setFromVector3": function () {}
};
THREE.Spline.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getControlPointsArray": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "initFromArray": function () {},
  "isCatmullRomCurve3": function () {},
  "reparametrizeByArcLength": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.SplineCurve.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isSplineCurve": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.SplineCurve3.prototype = {
  "clone": function () {},
  "computeFrenetFrames": function () {},
  "constructor": function () {},
  "copy": function () {},
  "fromJSON": function () {},
  "getLength": function () {},
  "getLengths": function () {},
  "getPoint": function () {},
  "getPointAt": function () {},
  "getPoints": function () {},
  "getSpacedPoints": function () {},
  "getTangent": function () {},
  "getTangentAt": function () {},
  "getUtoTmapping": function () {},
  "isCatmullRomCurve3": function () {},
  "toJSON": function () {},
  "updateArcLengths": function () {}
};
THREE.SpotLight.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLight": function () {},
  "isObject3D": function () {},
  "isSpotLight": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.SpotLightHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.SpotLightShadow.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "isSpotLightShadow": function () {},
  "toJSON": function () {},
  "update": function () {}
};
THREE.Sprite.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isObject3D": function () {},
  "isSprite": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.SpriteMaterial.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isMaterial": function () {},
  "isSpriteMaterial": function () {},
  "onBeforeCompile": function () {},
  "removeEventListener": function () {},
  "setValues": function () {},
  "toJSON": function () {}
};
THREE.StereoCamera.prototype = {
  "update": function () {}
};
THREE.StringKeyframeTrack.prototype = {
  "DefaultInterpolation": function () {},
  "InterpolantFactoryMethodDiscrete": function () {},
  "InterpolantFactoryMethodLinear": function () {},
  "InterpolantFactoryMethodSmooth": function () {},
  "TimeBufferType": function () {},
  "ValueBufferType": function () {},
  "ValueTypeName": function () {},
  "constructor": function () {},
  "getInterpolation": function () {},
  "getValueSize": function () {},
  "optimize": function () {},
  "scale": function () {},
  "setInterpolation": function () {},
  "shift": function () {},
  "trim": function () {},
  "validate": function () {}
};
THREE.TetrahedronBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.TetrahedronGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.TextBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "addShape": function () {},
  "addShapeList": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getArrays": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.TextGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.Texture.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isTexture": function () {},
  "removeEventListener": function () {},
  "toJSON": function () {},
  "transformUv": function () {}
};
THREE.TextureLoader.prototype = {
  "crossOrigin": function () {},
  "load": function () {},
  "setCrossOrigin": function () {},
  "setPath": function () {}
};
THREE.TorusBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.TorusGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.TorusKnotBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.TorusKnotGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.Triangle.prototype = {
  "area": function () {},
  "barycoordFromPoint": function () {},
  "clone": function () {},
  "closestPointToPoint": function () {},
  "containsPoint": function () {},
  "copy": function () {},
  "equals": function () {},
  "midpoint": function () {},
  "normal": function () {},
  "plane": function () {},
  "set": function () {},
  "setFromPointsAndIndices": function () {}
};
THREE.TubeBufferGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
THREE.TubeGeometry.prototype = {
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeFlatVertexNormals": function () {},
  "computeLineDistances": function () {},
  "computeMorphNormals": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromBufferGeometry": function () {},
  "hasEventListener": function () {},
  "isGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "mergeMesh": function () {},
  "mergeVertices": function () {},
  "normalize": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setFromPoints": function () {},
  "sortFacesByMaterialIndex": function () {},
  "toJSON": function () {},
  "translate": function () {}
};
THREE.Uint16BufferAttribute.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.Uint32BufferAttribute.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.Uint8BufferAttribute.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.Uint8ClampedBufferAttribute.prototype = {
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "copyArray": function () {},
  "copyAt": function () {},
  "copyColorsArray": function () {},
  "copyIndicesArray": function () {},
  "copyVector2sArray": function () {},
  "copyVector3sArray": function () {},
  "copyVector4sArray": function () {},
  "getW": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "isBufferAttribute": function () {},
  "onUpload": function () {},
  "set": function () {},
  "setArray": function () {},
  "setDynamic": function () {},
  "setW": function () {},
  "setX": function () {},
  "setXY": function () {},
  "setXYZ": function () {},
  "setXYZW": function () {},
  "setY": function () {},
  "setZ": function () {}
};
THREE.Uniform.prototype = {
  "clone": function () {}
};
THREE.Vector2.prototype = {
  "add": function () {},
  "addScalar": function () {},
  "addScaledVector": function () {},
  "addVectors": function () {},
  "angle": function () {},
  "applyMatrix3": function () {},
  "ceil": function () {},
  "clamp": function () {},
  "clampLength": function () {},
  "clampScalar": function () {},
  "clone": function () {},
  "copy": function () {},
  "distanceTo": function () {},
  "distanceToManhattan": function () {},
  "distanceToSquared": function () {},
  "divide": function () {},
  "divideScalar": function () {},
  "dot": function () {},
  "equals": function () {},
  "floor": function () {},
  "fromArray": function () {},
  "fromAttribute": function () {},
  "fromBufferAttribute": function () {},
  "getComponent": function () {},
  "isVector2": function () {},
  "length": function () {},
  "lengthManhattan": function () {},
  "lengthSq": function () {},
  "lerp": function () {},
  "lerpVectors": function () {},
  "manhattanDistanceTo": function () {},
  "manhattanLength": function () {},
  "max": function () {},
  "min": function () {},
  "multiply": function () {},
  "multiplyScalar": function () {},
  "negate": function () {},
  "normalize": function () {},
  "rotateAround": function () {},
  "round": function () {},
  "roundToZero": function () {},
  "set": function () {},
  "setComponent": function () {},
  "setLength": function () {},
  "setScalar": function () {},
  "setX": function () {},
  "setY": function () {},
  "sub": function () {},
  "subScalar": function () {},
  "subVectors": function () {},
  "toArray": function () {},
  "push": function () {}
};
THREE.Vector3.prototype = {
  "add": function () {},
  "addScalar": function () {},
  "addScaledVector": function () {},
  "addVectors": function () {},
  "angleTo": function () {},
  "applyAxisAngle": function () {},
  "applyEuler": function () {},
  "applyMatrix3": function () {},
  "applyMatrix4": function () {},
  "applyProjection": function () {},
  "applyQuaternion": function () {},
  "ceil": function () {},
  "clamp": function () {},
  "clampLength": function () {},
  "clampScalar": function () {},
  "clone": function () {},
  "copy": function () {},
  "cross": function () {},
  "crossVectors": function () {},
  "distanceTo": function () {},
  "distanceToManhattan": function () {},
  "distanceToSquared": function () {},
  "divide": function () {},
  "divideScalar": function () {},
  "dot": function () {},
  "equals": function () {},
  "floor": function () {},
  "fromArray": function () {},
  "fromAttribute": function () {},
  "fromBufferAttribute": function () {},
  "getColumnFromMatrix": function () {},
  "getComponent": function () {},
  "getPositionFromMatrix": function () {},
  "getScaleFromMatrix": function () {},
  "isVector3": function () {},
  "length": function () {},
  "lengthManhattan": function () {},
  "lengthSq": function () {},
  "lerp": function () {},
  "lerpVectors": function () {},
  "manhattanDistanceTo": function () {},
  "manhattanLength": function () {},
  "max": function () {},
  "min": function () {},
  "multiply": function () {},
  "multiplyScalar": function () {},
  "multiplyVectors": function () {},
  "negate": function () {},
  "normalize": function () {},
  "project": function () {},
  "projectOnPlane": function () {},
  "projectOnVector": function () {},
  "reflect": function () {},
  "round": function () {},
  "roundToZero": function () {},
  "set": function () {},
  "setComponent": function () {},
  "setEulerFromQuaternion": function () {},
  "setEulerFromRotationMatrix": function () {},
  "setFromCylindrical": function () {},
  "setFromMatrixColumn": function () {},
  "setFromMatrixPosition": function () {},
  "setFromMatrixScale": function () {},
  "setFromSpherical": function () {},
  "setLength": function () {},
  "setScalar": function () {},
  "setX": function () {},
  "setY": function () {},
  "setZ": function () {},
  "sub": function () {},
  "subScalar": function () {},
  "subVectors": function () {},
  "toArray": function () {},
  "transformDirection": function () {},
  "unproject": function () {},
  "push": function () {}
};
THREE.Vector4.prototype = {
  "add": function () {},
  "addScalar": function () {},
  "addScaledVector": function () {},
  "addVectors": function () {},
  "applyMatrix4": function () {},
  "ceil": function () {},
  "clamp": function () {},
  "clampLength": function () {},
  "clampScalar": function () {},
  "clone": function () {},
  "copy": function () {},
  "divideScalar": function () {},
  "dot": function () {},
  "equals": function () {},
  "floor": function () {},
  "fromArray": function () {},
  "fromAttribute": function () {},
  "fromBufferAttribute": function () {},
  "getComponent": function () {},
  "isVector4": function () {},
  "length": function () {},
  "lengthManhattan": function () {},
  "lengthSq": function () {},
  "lerp": function () {},
  "lerpVectors": function () {},
  "manhattanLength": function () {},
  "max": function () {},
  "min": function () {},
  "multiplyScalar": function () {},
  "negate": function () {},
  "normalize": function () {},
  "round": function () {},
  "roundToZero": function () {},
  "set": function () {},
  "setAxisAngleFromQuaternion": function () {},
  "setAxisAngleFromRotationMatrix": function () {},
  "setComponent": function () {},
  "setLength": function () {},
  "setScalar": function () {},
  "setW": function () {},
  "setX": function () {},
  "setY": function () {},
  "setZ": function () {},
  "sub": function () {},
  "subScalar": function () {},
  "subVectors": function () {},
  "toArray": function () {},
  "push": function () {}
};
THREE.VectorKeyframeTrack.prototype = {
  "DefaultInterpolation": function () {},
  "InterpolantFactoryMethodDiscrete": function () {},
  "InterpolantFactoryMethodLinear": function () {},
  "InterpolantFactoryMethodSmooth": function () {},
  "TimeBufferType": function () {},
  "ValueBufferType": function () {},
  "ValueTypeName": function () {},
  "constructor": function () {},
  "getInterpolation": function () {},
  "getValueSize": function () {},
  "optimize": function () {},
  "scale": function () {},
  "setInterpolation": function () {},
  "shift": function () {},
  "trim": function () {},
  "validate": function () {}
};
THREE.VertexNormalsHelper.prototype = {
  "add": function () {},
  "addEventListener": function () {},
  "applyMatrix": function () {},
  "applyQuaternion": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "getChildByName": function () {},
  "getObjectById": function () {},
  "getObjectByName": function () {},
  "getObjectByProperty": function () {},
  "getWorldDirection": function () {},
  "getWorldPosition": function () {},
  "getWorldQuaternion": function () {},
  "getWorldRotation": function () {},
  "getWorldScale": function () {},
  "hasEventListener": function () {},
  "isLine": function () {},
  "isLineSegments": function () {},
  "isObject3D": function () {},
  "localToWorld": function () {},
  "lookAt": function () {},
  "onAfterRender": function () {},
  "onBeforeRender": function () {},
  "raycast": function () {},
  "remove": function () {},
  "removeEventListener": function () {},
  "renderDepth": function () {},
  "rotateOnAxis": function () {},
  "rotateOnWorldAxis": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "setRotationFromAxisAngle": function () {},
  "setRotationFromEuler": function () {},
  "setRotationFromMatrix": function () {},
  "setRotationFromQuaternion": function () {},
  "toJSON": function () {},
  "translate": function () {},
  "translateOnAxis": function () {},
  "translateX": function () {},
  "translateY": function () {},
  "translateZ": function () {},
  "traverse": function () {},
  "traverseAncestors": function () {},
  "traverseVisible": function () {},
  "update": function () {},
  "updateMatrix": function () {},
  "updateMatrixWorld": function () {},
  "worldToLocal": function () {}
};
THREE.VideoTexture.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isTexture": function () {},
  "isVideoTexture": function () {},
  "removeEventListener": function () {},
  "toJSON": function () {},
  "transformUv": function () {},
  "update": function () {}
};
THREE.WebGLRenderTarget.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isWebGLRenderTarget": function () {},
  "removeEventListener": function () {},
  "setSize": function () {}
};
THREE.WebGLRenderTargetCube.prototype = {
  "addEventListener": function () {},
  "clone": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "hasEventListener": function () {},
  "isWebGLRenderTarget": function () {},
  "isWebGLRenderTargetCube": function () {},
  "removeEventListener": function () {},
  "setSize": function () {}
};
THREE.WebGLRenderer.prototype = {
  "addPostPlugin": function () {},
  "addPrePlugin": function () {},
  "enableScissorTest": function () {},
  "getCurrentRenderTarget": function () {},
  "getMaxAnisotropy": function () {},
  "getPrecision": function () {},
  "initMaterial": function () {},
  "resetGLState": function () {},
  "supportsBlendMinMax": function () {},
  "supportsCompressedTexturePVRTC": function () {},
  "supportsCompressedTextureS3TC": function () {},
  "supportsFloatTextures": function () {},
  "supportsHalfFloatTextures": function () {},
  "supportsInstancedArrays": function () {},
  "supportsStandardDerivatives": function () {},
  "supportsVertexTextures": function () {},
  "updateShadowMap": function () {},
  "render": function () {},
  "setViewport": function () {}
};
THREE.WireframeGeometry.prototype = {
  "addAttribute": function () {},
  "addDrawCall": function () {},
  "addEventListener": function () {},
  "addGroup": function () {},
  "addIndex": function () {},
  "applyMatrix": function () {},
  "center": function () {},
  "clearDrawCalls": function () {},
  "clearGroups": function () {},
  "clone": function () {},
  "computeBoundingBox": function () {},
  "computeBoundingSphere": function () {},
  "computeFaceNormals": function () {},
  "computeOffsets": function () {},
  "computeTangents": function () {},
  "computeVertexNormals": function () {},
  "constructor": function () {},
  "copy": function () {},
  "dispatchEvent": function () {},
  "dispose": function () {},
  "fromDirectGeometry": function () {},
  "fromGeometry": function () {},
  "getAttribute": function () {},
  "getIndex": function () {},
  "hasEventListener": function () {},
  "isBufferGeometry": function () {},
  "lookAt": function () {},
  "merge": function () {},
  "normalizeNormals": function () {},
  "removeAttribute": function () {},
  "removeEventListener": function () {},
  "rotateX": function () {},
  "rotateY": function () {},
  "rotateZ": function () {},
  "scale": function () {},
  "setDrawRange": function () {},
  "setFromObject": function () {},
  "setFromPoints": function () {},
  "setIndex": function () {},
  "toJSON": function () {},
  "toNonIndexed": function () {},
  "translate": function () {},
  "updateFromObject": function () {}
};
/**********************************************************************
 * End Generated Extern for THREE
 /**********************************************************************/
